<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clinical Q&A Engine | EBM Sessions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <div class="app-root">
    <div class="shell">
      <div class="layout">
        <!-- SIDEBAR -->
        <aside class="sidebar">
          <div class="sidebar-header">
            <div class="sidebar-brand">
              <div class="brand-logo">EBM</div>
              <div class="brand-text">
                <div class="brand-title">EBM Sessions</div>
              </div>
            </div>
            <input
              id="topicSearch"
              class="topic-search"
              type="text"
              placeholder="Search topics..."
            />
          </div>

          <div id="conversationList" class="conversation-list">
            <!-- Filled in by JS -->
          </div>

          <div class="sidebar-footer">
            <span class="sidebar-hint">Locally stored â€¢ Per device</span>
          </div>
        </aside>

        <!-- MAIN REGION -->
        <div class="main-region">
          <header class="header">
            <h1 class="title">Clinical Q&amp;A Engine</h1>
            <p class="subtitle">
              Enter a clinical question to generate an evidence based answer.
            </p>
          </header>

          <main class="grid">
            <!-- CLINICAL QUESTION -->
            <section class="card input-card">
              <label class="label" for="question">Clinical Question</label>
              <textarea
                id="question"
                class="textarea"
                rows="6"
                placeholder="e.g. Evidence-based management of new-onset atrial fibrillation in a haemodynamically stable adult?"
              ></textarea>

              <div class="actions">
                <button id="generateBtn" class="btn">Generate</button>
              </div>
            </section>

            <!-- ANSWERS -->
            <section class="card output-card">
              <div class="output-header">
                <h2 class="output-title">Answers</h2>
                <button id="copyAllBtn" class="copy-btn main-copy-btn" disabled>Copy All</button>
              </div>

              <!-- LOADER OVERLAY -->
              <div id="answerLoader" class="answer-loader hidden">
                <div class="loader"></div>
                <div class="loader-text">Generating structured answerâ€¦</div>
              </div>

              <div class="output-body">
                <div id="answer" class="answer placeholder">
                  Your structured, evidence-based response will appear here.
                </div>
              </div>

              <!-- FOLLOW UP -->
              <div class="followup-container">
                <label for="followupInput" class="followup-label">
                  Ask a follow-up question about this answer
                </label>
                <div class="followup-row">
                  <input
                    id="followupInput"
                    class="followup-input"
                    type="text"
                    placeholder=""
                  />
                  <button id="followupBtn" class="followup-btn">Ask</button>
                </div>
              </div>
            </section>
          </main>
        </div>
      </div>
    </div>
  </div>

  <script>
    const questionInput = document.getElementById("question");
    const generateBtn = document.getElementById("generateBtn");
    const answerEl = document.getElementById("answer");
    const copyAllBtn = document.getElementById("copyAllBtn");
    const answerLoader = document.getElementById("answerLoader");
    const conversationListEl = document.getElementById("conversationList");
    const topicSearch = document.getElementById("topicSearch");
    const followupInput = document.getElementById("followupInput");
    const followupBtn = document.getElementById("followupBtn");

    let conversations = [];
    let activeId = null;

    /* ---------- UTILITIES ---------- */

    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function flashCopyLabel(btn) {
      const original = btn.textContent;
      btn.textContent = "Copied";
      btn.classList.add("copied");
      setTimeout(() => {
        btn.textContent = original;
        btn.classList.remove("copied");
      }, 900);
    }

    function hasNonEmptyContent(arr) {
      return Array.isArray(arr) && arr.some((l) => l.trim() !== "");
    }

    /* ---------- CONVERSATIONS (LOCAL STORAGE) ---------- */

    function loadConversations() {
      try {
        const raw = localStorage.getItem("ebm_conversations");
        const active = localStorage.getItem("ebm_active");
        conversations = raw ? JSON.parse(raw) : [];
        activeId = active || (conversations[0] && conversations[0].id) || null;
      } catch {
        conversations = [];
        activeId = null;
      }
      renderConversationList();
      restoreActiveConversation();
      filterTopics();
    }

    function saveConversations() {
      try {
        localStorage.setItem(
          "ebm_conversations",
          JSON.stringify(conversations.slice(0, 80))
        );
        if (activeId) localStorage.setItem("ebm_active", activeId);
      } catch (e) {
        console.warn("Unable to save conversations", e);
      }
    }

    function renderConversationList() {
      conversationListEl.innerHTML = "";
      if (!conversations.length) {
        conversationListEl.innerHTML =
          '<div class="conv-empty">No topics yet. Generate an answer to save it.</div>';
        return;
      }
      conversations.forEach((c) => {
        const title = (c.title || "Untitled topic").slice(0, 80);
        const preview =
          (c.question || "").slice(0, 90) ||
          (c.updatedAt || "").slice(0, 10);

        const div = document.createElement("div");
        div.className = "conv-item" + (c.id === activeId ? " active" : "");
        div.dataset.id = c.id;
        div.dataset.title = title;
        div.dataset.question = c.question || "";
        div.innerHTML = `
          <div class="conv-title">${escapeHtml(title)}</div>
          <div class="conv-sub">${escapeHtml(preview || "")}</div>
        `;
        conversationListEl.appendChild(div);
      });
    }

    function restoreActiveConversation() {
      if (!activeId) {
        questionInput.value = "";
        answerEl.innerHTML =
          "Your structured, evidence-based response will appear here.";
        answerEl.classList.add("placeholder");
        copyAllBtn.disabled = true;
        return;
      }
      const conv = conversations.find((c) => c.id === activeId);
      if (!conv) {
        activeId = null;
        renderConversationList();
        restoreActiveConversation();
        return;
      }
      questionInput.value = conv.question || "";
      if (conv.answerHtml) {
        answerEl.innerHTML = conv.answerHtml;
        answerEl.classList.remove("placeholder");
        copyAllBtn.disabled = false;
      } else {
        answerEl.innerHTML =
          "Your structured, evidence-based response will appear here.";
        answerEl.classList.add("placeholder");
        copyAllBtn.disabled = true;
      }
    }

    function setActiveConversation(id) {
      activeId = id;
      saveConversations();
      renderConversationList();
      restoreActiveConversation();
      filterTopics();
    }

    function ensureConversationSlotForQuery(query) {
      if (!query) return;

      if (!activeId || !conversations.length) {
        activeId = "c_" + Date.now();
        return;
      }

      const current = conversations.find((c) => c.id === activeId);
      if (!current) {
        activeId = "c_" + Date.now();
        return;
      }

      if (!current.answerHtml) return;
      if (current.question && current.question.trim() === query.trim()) return;

      activeId = "c_" + Date.now();
    }

    function saveActiveConversation(question, answerHtml) {
      if (!activeId) activeId = "c_" + Date.now();

      const title = (question || "Untitled topic").trim() || "Untitled topic";
      const now = new Date().toISOString();

      const idx = conversations.findIndex((c) => c.id === activeId);
      const conv = {
        id: activeId,
        title: title.slice(0, 80),
        question,
        answerHtml,
        updatedAt: now,
      };

      if (idx >= 0) {
        conversations[idx] = conv;
      } else {
        conversations.unshift(conv);
      }

      saveConversations();
      renderConversationList();
      filterTopics();
    }

    /* ---------- TOPIC SEARCH ---------- */

    function filterTopics() {
      if (!topicSearch) return;
      const term = topicSearch.value.trim().toLowerCase();
      const items = conversationListEl.querySelectorAll(".conv-item");
      if (!items.length) return;

      items.forEach((item) => {
        if (!term) {
          item.style.display = "";
          return;
        }
        const title = (item.dataset.title || "").toLowerCase();
        const question = (item.dataset.question || "").toLowerCase();
        const match = title.includes(term) || question.includes(term);
        item.style.display = match ? "" : "none";
      });
    }

    if (topicSearch) {
      topicSearch.addEventListener("input", filterTopics);
    }

    /* ---------- STRUCTURED HTML BUILDER ---------- */

    function buildStructuredHtml(raw) {
      if (!raw) return "";

      let text = raw
        .replace(/\*\*(.*?)\*\*/g, "$1")
        .replace(/#{1,6}\s*/g, "")
        .replace(/\r/g, "");

      const lines = text.split("\n");

      const sectionOrder = [
        "Summary",
        "Assessment",
        "Investigations",
        "Treatment",
        "Management",
        "Monitoring",
        "Follow-up & Safety Netting",
        "Follow-up",
        "Red Flags",
        "References"
      ];

      const sections = [];
      let current = { title: "Summary", content: [] };
      let seenExplicitHeading = false;

      const isHeadingLine = (line) => {
        const trimmed = line.trim();
        const match = sectionOrder.find(
          (h) => trimmed.toLowerCase() === (h + ":").toLowerCase()
        );
        return match || null;
      };

      for (const rawLine of lines) {
        const line = rawLine.trim();
        if (!line) {
          current.content.push("");
          continue;
        }

        const heading = isHeadingLine(line);
        if (heading) {
          if (hasNonEmptyContent(current.content)) {
            sections.push(current);
          }
          current = { title: heading, content: [] };
          seenExplicitHeading = true;
        } else {
          current.content.push(line);
        }
      }

      if (hasNonEmptyContent(current.content)) {
        sections.push(current);
      }

      let html = "";
      let sectionIndex = 0;

      // No explicit headings â†’ treat as single Summary
      if (!seenExplicitHeading && sections.length === 1 && sections[0].title === "Summary") {
        const body = sections[0].content.join(" ").trim();
        if (!body) return "No response generated.";
        const id = `sec-${sectionIndex++}`;
        html += `
          <div class="section">
            <div class="section-header static">
              <span>Summary</span>
              <button class="section-copy-btn" data-target="${id}">Copy</button>
            </div>
            <div class="section-body static-body" data-section="${id}">
              <p>${escapeHtml(body)}</p>
            </div>
          </div>
        `;
        return html;
      }

      for (const sec of sections) {
        const title = sec.title;
        const bodyLines = sec.content || [];

        // ðŸ’¡ Skip empty sections completely (fixes blank boxes)
        if (!hasNonEmptyContent(bodyLines)) continue;

        const id = `sec-${sectionIndex++}`;

        // SUMMARY (fixed block)
        if (title === "Summary") {
          html += `
            <div class="section">
              <div class="section-header static">
                <span>Summary</span>
                <button class="section-copy-btn" data-target="${id}">Copy</button>
              </div>
              <div class="section-body static-body" data-section="${id}">
                ${bodyLines
                  .map((ln) => {
                    const t = ln.trim();
                    if (!t) return "";
                    if (/^[-â€¢]\s+/.test(t) || /^\d+[\.\)]\s+/.test(t)) {
                      const cleaned = t
                        .replace(/^[-â€¢]\s+/, "")
                        .replace(/^\d+[\.\)]\s+/, "");
                      return `
                        <div class="answer-bullet">
                          <span class="bullet-dot"></span>
                          <span class="bullet-text">${escapeHtml(cleaned)}</span>
                        </div>
                      `;
                    }
                    return `<p class="answer-paragraph">${escapeHtml(t)}</p>`;
                  })
                  .join("")}
              </div>
            </div>
          `;
          continue;
        }

        // OTHER SECTIONS â†’ collapsible
        const innerHtml =
          (title === "Treatment" || title === "Management")
            ? buildTreatmentContent(bodyLines)
            : bodyLines
                .filter((ln) => ln.trim() !== "")
                .map((ln) => {
                  const t = ln.trim();
                  if (/^[-â€¢]\s+/.test(t) || /^\d+[\.\)]\s+/.test(t)) {
                    const cleaned = t
                      .replace(/^[-â€¢]\s+/, "")
                      .replace(/^\d+[\.\)]\s+/, "");
                    return `
                      <div class="answer-bullet">
                        <span class="bullet-dot"></span>
                        <span class="bullet-text">${escapeHtml(cleaned)}</span>
                      </div>
                    `;
                  }
                  return `<p class="answer-paragraph">${escapeHtml(t)}</p>`;
                })
                .join("");

        if (!innerHtml.trim()) continue; // again skip if nothing

        html += `
          <div class="section">
            <div class="collapsible-header">
              <button class="collapsible" data-target="${id}">${escapeHtml(title)}</button>
              <button class="section-copy-btn" data-target="${id}">Copy</button>
            </div>
            <div class="collapsible-content" data-section="${id}">
              ${innerHtml}
            </div>
          </div>
        `;
      }

      return html || "No response generated.";
    }

    function buildTreatmentContent(lines) {
      let html = "";
      let currentOption = null;

      const flushOption = () => {
        if (currentOption && hasNonEmptyContent(currentOption.details)) {
          const label = escapeHtml(currentOption.label);
          const content = escapeHtml(currentOption.details.join(" ").trim());
          html += `
            <div class="nested-block">
              <button class="nested-toggle">${label}</button>
              <div class="nested-content">
                <p>${content}</p>
              </div>
            </div>
          `;
        }
        currentOption = null;
      };

      for (const raw of lines) {
        const line = raw.trim();
        if (!line) continue;

        if (/^Option:\s*/i.test(line)) {
          flushOption();
          const label = line.replace(/^Option:\s*/i, "").trim() || "Option";
          currentOption = { label, details: [] };
        } else if (/^Detail:\s*/i.test(line)) {
          const text = line.replace(/^Detail:\s*/i, "").trim();
          if (!currentOption) currentOption = { label: "Detail", details: [] };
          if (text) currentOption.details.push(text);
        } else if (/^[-â€¢]\s+/.test(line) || /^\d+[\.\)]\s+/.test(line)) {
          const cleaned = line
            .replace(/^[-â€¢]\s+/, "")
            .replace(/^\d+[\.\)]\s+/, "");
          if (currentOption) {
            currentOption.details.push(cleaned);
          } else {
            html += `
              <div class="answer-bullet">
                <span class="bullet-dot"></span>
                <span class="bullet-text">${escapeHtml(cleaned)}</span>
              </div>
            `;
          }
        } else {
          if (currentOption) {
            currentOption.details.push(line);
          } else {
            html += `<p class="answer-paragraph">${escapeHtml(line)}</p>`;
          }
        }
      }

      flushOption();

      if (!html.trim()) {
        html = lines
          .filter((l) => l.trim() !== "")
          .map((l) => `<p class="answer-paragraph">${escapeHtml(l.trim())}</p>`)
          .join("");
      }

      return html;
    }

    /* ---------- GENERATE (STREAMING) ---------- */

    async function generate() {
      const query = questionInput.value.trim();
      if (!query) return;

      ensureConversationSlotForQuery(query);

      generateBtn.disabled = true;
      copyAllBtn.disabled = true;
      followupBtn.disabled = true;
      answerLoader.classList.remove("hidden");
      answerEl.classList.remove("placeholder");
      answerEl.innerHTML = "";

      try {
        const response = await fetch("/api/generate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query }),
        });

        if (!response.body) {
          const text = await response.text();
          answerEl.textContent = text || "No response generated.";
        } else {
          const reader = response.body.getReader();
          const decoder = new TextDecoder("utf-8");
          let text = "";

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });
            if (chunk) {
              text += chunk;
              answerEl.textContent = text; // live preview of raw text
            }
          }

          const structured = buildStructuredHtml(text);
          answerEl.innerHTML = structured;
          saveActiveConversation(query, structured);
        }

        copyAllBtn.disabled = !answerEl.textContent.trim();
      } catch (err) {
        console.error(err);
        answerEl.textContent = "Error generating answer.";
        copyAllBtn.disabled = true;
      } finally {
        generateBtn.disabled = false;
        followupBtn.disabled = false;
        answerLoader.classList.add("hidden");
      }
    }

    /* ---------- FOLLOW-UP (STREAMING) ---------- */

    async function generateFollowup() {
      const follow = followupInput.value.trim();
      if (!follow) return;

      const conv = conversations.find((c) => c.id === activeId);
      if (!conv || !conv.answerHtml || !conv.question) return;

      followupBtn.disabled = true;
      generateBtn.disabled = true;
      copyAllBtn.disabled = true;
      answerLoader.classList.remove("hidden");

      const combinedQuery =
        conv.question + "\n\nFollow-up question: " + follow;

      try {
        const response = await fetch("/api/generate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: combinedQuery }),
        });

        let text = "";

        if (!response.body) {
          text = await response.text();
        } else {
          const reader = response.body.getReader();
          const decoder = new TextDecoder("utf-8");

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });
            if (chunk) {
              text += chunk;
              // don't overwrite main; this is just building up
            }
          }
        }

        if (text.trim()) {
          const structured = buildStructuredHtml(text);
          const block = `
            <div class="followup-block">
              <div class="followup-question">Follow-up: ${escapeHtml(follow)}</div>
              ${structured}
            </div>
          `;
          answerEl.classList.remove("placeholder");
          answerEl.innerHTML += block;

          conv.answerHtml = answerEl.innerHTML;
          conv.updatedAt = new Date().toISOString();
          saveConversations();
        }

        followupInput.value = "";
        copyAllBtn.disabled = !answerEl.textContent.trim();
      } catch (err) {
        console.error(err);
      } finally {
        answerLoader.classList.add("hidden");
        followupBtn.disabled = false;
        generateBtn.disabled = false;
      }
    }

    /* ---------- EVENTS ---------- */

    generateBtn.addEventListener("click", generate);

    questionInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        generate();
      }
    });

    copyAllBtn.addEventListener("click", async () => {
      const text = answerEl.textContent.trim();
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        flashCopyLabel(copyAllBtn);
      } catch (err) {
        console.error(err);
      }
    });

    if (followupBtn && followupInput) {
      followupBtn.addEventListener("click", generateFollowup);
      followupInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          generateFollowup();
        }
      });
    }

    document.addEventListener("click", async (e) => {
      const convItem = e.target.closest(".conv-item");
      if (convItem) {
        const id = convItem.dataset.id;
        if (id) setActiveConversation(id);
        return;
      }

      if (e.target.classList.contains("section-copy-btn")) {
        const id = e.target.dataset.target;
        if (!id) return;
        const section = document.querySelector(`[data-section="${id}"]`);
        if (!section) return;
        const text = section.innerText.trim();
        if (!text) return;
        try {
          await navigator.clipboard.writeText(text);
          flashCopyLabel(e.target);
        } catch (err) {
          console.error(err);
        }
        return;
      }

      if (e.target.classList.contains("collapsible")) {
        const id = e.target.dataset.target;
        const content = document.querySelector(
          `.collapsible-content[data-section="${id}"]`
        );
        if (!content) return;
        const isOpen = content.style.display === "block";
        e.target.classList.toggle("active", !isOpen);
        content.style.display = isOpen ? "none" : "block";
        return;
      }

      if (e.target.classList.contains("nested-toggle")) {
        const content = e.target.nextElementSibling;
        if (!content) return;
        const isOpen = content.style.display === "block";
        e.target.classList.toggle("active", !isOpen);
        content.style.display = isOpen ? "none" : "block";
        return;
      }
    });

    /* ---------- INIT ---------- */
    loadConversations();
  </script>
</body>
</html>
