<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>VividMedi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css', v=config['VERSION']) }}">
  <!-- If you use Google Sign-In in your app.py, keep this: -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>

<body>
  <div class="app-root">
    <div class="shell">
      <div class="layout">

        <!-- SIDEBAR -->
        <aside class="sidebar">
          <div class="sidebar-header">
            <div class="sidebar-brand">
              <div class="vm-mark vm-mark--sm" aria-hidden="true">
                <span class="vm-plus"></span>
              </div>
              <div class="brand-text">
                <div class="brand-title">VividMedi</div>
                <div class="sidebar-title">Clinical Intelligence Engine</div>
              </div>
            </div>

            <input id="sidebarSearch" class="topic-search" type="text" placeholder="Search saved..." />
          </div>

          <div class="sidebar-subhead">Saved Clinical Questions</div>
          <div id="savedQuestionsList" class="conversation-list"></div>

          <div class="sidebar-subhead">Consultation Notes (saved)</div>
          <div id="savedWrList" class="conversation-list"></div>

          <div class="sidebar-subhead">Handovers (saved)</div>
          <div id="savedHandoverList" class="conversation-list"></div>

          <div class="sidebar-footer">
            <span class="sidebar-hint">Locally stored ‚Ä¢ Per device</span>
          </div>
        </aside>

        <!-- MAIN -->
        <div class="main-region">
          <header class="header">
            <div class="brand-header">
              <div class="vm-mark vm-mark--lg" aria-hidden="true">
                <span class="vm-plus"></span>
              </div>
              <div class="brand-header__text">
                <h1 class="brand-header__name">VividMedi</h1>
                <div class="brand-header__tagline">Clinical Intelligence Engine</div>
              </div>
            </div>

            <!-- Optional: if you already support google sign-in in app.py -->
            <div class="topbar-actions">
              <div id="gSignIn" class="gsi-wrap"></div>
            </div>
          </header>

          <!-- TOP ROW -->
          <main class="grid">

            <!-- QUESTION -->
            <section class="card input-card">
              <label class="label" for="clinicalQuestion">Clinical</label>

              <div class="mode-row">
                <label class="label label-tight mode-label">Mode</label>
                <select id="modeSelect" class="topic-search mode-select">
                  <option value="clinical" selected>Clinical</option>
                  <option value="dva_new">DVA D0904 (New referral)</option>
                  <option value="dva_renew">DVA D0904 (Renewal / EoC-based)</option>
                </select>
              </div>

              <textarea id="clinicalQuestion" class="textarea" rows="7" placeholder=""></textarea>

              <div class="actions actions-compact">
                <button id="generateBtn" class="btn btn-primary" type="button">Generate</button>
                <button id="dictateQuestionBtn" class="btn" type="button">üéô Dictate</button>
                <button id="incorrectQuestionBtn" class="btn" type="button">Incorrect</button>
                <button id="clearQuestionBtn" class="btn btn-danger" type="button">Clear</button>
              </div>

              <div id="qStatus" class="mic-status">Question mic: idle</div>
            </section>

            <!-- ANSWER -->
            <section class="card output-card">
              <div class="output-header">
                <div class="output-header-flex">
                  <h2 class="output-title-inline">Answers</h2>
                  <button id="sendToConsultBtn" class="copy-btn" type="button" disabled>Send to Consult output</button>
                  <button id="copyAllBtn" class="copy-btn main-copy-btn" disabled type="button">Copy All</button>
                </div>
              </div>

              <div id="answerLoader" class="answer-loader hidden">
                <div class="loader"></div>
                <div class="loader-text">Generating structured answer‚Ä¶</div>
              </div>

              <div class="output-body">
                <div id="answer" class="answer placeholder">Your answer will appear here.</div>
              </div>
            </section>
          </main>

          <div class="divider-spacer"></div>

          <!-- CONSULTATION NOTES -->
          <section class="card wr-card">
            <div class="wr-head">
              <div style="min-width:260px;">
                <div class="label wr-label">Consultation Notes</div>

                <div class="mode-row" style="margin-top:8px;">
                  <label class="label label-tight mode-label">Mode</label>

                  <!-- IMPORTANT: this select must NOT be clipped by parents; style.css patch below -->
                  <select id="consultModeSelect" class="topic-search mode-select" style="max-width:360px;">
                    <option value="consult_note" selected>Create clinical note</option>
                    <option value="handover">Handover summary</option>
                    <option value="dva_authority">DVA authority numbers</option>
                    <option value="initial_consult">Initial patient consultation</option>
                    <option value="follow_up">Follow up review</option>
                    <option value="specialist_letter">Specialist letter</option>
                    <option value="discharge_summary">Discharge summary</option>
                  </select>
                </div>
              </div>

              <div class="actions actions-compact wr-actions">
                <button id="consultGenerateBtn" class="btn btn-primary" type="button">Generate</button>
                <!-- Add inside Consultation Notes actions area -->
                  <span class="spinner"></span>
                  <span class="mini-loader-text">Generating‚Ä¶</span>
                </div>
                <button id="dictateWrBtn" class="btn" type="button">üéô Dictate</button>
                <button id="incorrectWrBtn" class="btn" type="button">Incorrect</button>
                <button id="copyWrBtn" class="btn" type="button">Copy</button>
                <button id="ClearWrBtn" class="btn btn-danger" type="button">Clear</button>

                <!-- Smart device placeholder menu (no DeepSeek prompt change yet) -->
                <div class="device-menu">
                  <button id="connectDeviceBtn" class="btn" type="button">Smart device data collection ‚ñæ</button>
                  <div id="deviceMenuPanel" class="device-menu-panel" role="menu" aria-label="Smart device data collection">
                    <button type="button" data-device="ai_glasses">AI glasses</button>
                    <button type="button" data-device="smart_watch">Smart watch</button>
                    <button type="button" data-device="smart_ring">Smart ring</button>
                    <button type="button" data-device="ai_necklace">AI necklace</button>
                  </div>
                </div>
              </div>
            </div>

            <textarea id="wrNote" class="textarea" rows="12" placeholder=""></textarea>
            <div id="wrStatus" class="mic-status">Notes mic: idle</div>

            <div class="divider-spacer"></div>

            <div class="label wr-label">Consult output</div>
            <textarea id="wrOutput" class="textarea" rows="10" placeholder="Generated output will appear here (editable)"></textarea>
          </section>

        </div>
      </div>
    </div>
  </div>

<!-- ===========================
     IMPORTANT:
     All JS MUST stay inside this <script> tag.
     If you paste code below OUTSIDE <script>, it will render as text and break the UI.
=========================== -->
<script>
window.addEventListener("DOMContentLoaded", () => {
  // Storage keys
  const STORE_Q_CORR = "ebm_q_corrections_v7";
  const STORE_WR_CORR = "ebm_wr_corrections_v7";
  const STORE_SAVED_QA = "ebm_saved_qa_v7";
  const STORE_SAVED_NOTES = "ebm_saved_notes_v7";
  const STORE_SAVED_HANDOVERS = "ebm_saved_handovers_v7";

  // Elements
const modeSelect = document.getElementById("modeSelect");
const consultModeSelect = document.getElementById("consultModeSelect");

const clinicalQuestion = document.getElementById("clinicalQuestion");
const generateBtn = document.getElementById("generateBtn");
const dictateQuestionBtn = document.getElementById("dictateQuestionBtn");
const incorrectQuestionBtn = document.getElementById("incorrectQuestionBtn");
const clearQuestionBtn = document.getElementById("clearQuestionBtn");

const wrNote = document.getElementById("wrNote");
const wrOutput = document.getElementById("wrOutput");
const consultGenerateBtn = document.getElementById("consultGenerateBtn");

// ‚úÖ add this near consult elements (so generateConsult can use it)
const wrAnswerLoader = document.getElementById("wrAnswerLoader");

const connectDeviceBtn = document.getElementById("connectDeviceBtn");
const deviceMenuPanel = document.getElementById("deviceMenuPanel");

const dictateWrBtn = document.getElementById("dictateWrBtn");
const incorrectWrBtn = document.getElementById("incorrectWrBtn");
const copyWrBtn = document.getElementById("copyWrBtn");
const saveWrBtn = document.getElementById("saveWrBtn");

// Keep id as-is so your existing JS doesn‚Äôt break.
// The button label can be "Clear" in HTML, but the id can stay newWrBtn.
const newWrBtn = document.getElementById("newWrBtn");

const answerEl = document.getElementById("answer");
const answerLoader = document.getElementById("answerLoader"); // clinical loader (top section)
const copyAllBtn = document.getElementById("copyAllBtn");
const sendToConsultBtn = document.getElementById("sendToConsultBtn");

const qStatus = document.getElementById("qStatus");
const wrStatus = document.getElementById("wrStatus");

const savedQuestionsList = document.getElementById("savedQuestionsList");
const savedWrList = document.getElementById("savedWrList");
const savedHandoverList = document.getElementById("savedHandoverList");
const sidebarSearch = document.getElementById("sidebarSearch");

  // Utils
  function norm(s) { return (s || "").toLowerCase().replace(/\s+/g, " ").trim(); }
  function escapeHtml(str) {
    return (str || "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
  }
  function safeJsonParse(s, fallback){ try { return JSON.parse(s); } catch { return fallback; } }
  async function copyText(text){ if (!text) return; try { await navigator.clipboard.writeText(text); } catch {} }
  function flashStatus(el, msg){ if (el) el.textContent = msg; }

  // ===== Structured answer builder (collapsible sections) =====
  function hasNonEmpty(arr){ return Array.isArray(arr) && arr.some(l => (l||"").trim() !== ""); }

  function buildStructuredHtml(raw) {
    if (!raw) return "";
    let text = String(raw)
      .replace(/\r/g, "")
      .replace(/\*\*(.*?)\*\*/g, "$1")
      .replace(/#{1,6}\s*/g, "");

    const sectionOrder = [
      "Summary",
      "Assessment",
      "Diagnosis",
      "Investigations",
      "Treatment",
      "Monitoring",
      "Follow-up & Safety Netting",
      "Red Flags",
      "References",
    ];

    const lines = text.split("\n");
    const sections = [];
    let current = { title: "Summary", content: [] };
    let seenExplicit = false;

    function isHeading(line){
      const t = (line||"").trim().replace(/:$/, "");
      const match = sectionOrder.find(h => h.toLowerCase() === t.toLowerCase());
      return match || null;
    }

    for (const rawLine of lines) {
      const line = (rawLine||"").trim();
      if (!line) { current.content.push(""); continue; }
      const heading = isHeading(line);
      if (heading) {
        if (hasNonEmpty(current.content)) sections.push(current);
        current = { title: heading, content: [] };
        seenExplicit = true;
      } else {
        current.content.push(line);
      }
    }
    if (hasNonEmpty(current.content)) sections.push(current);

    if (!seenExplicit) {
      return `<div class="answer-paragraph">${escapeHtml(text)}</div>`;
    }

    let html = "";
    let idx = 0;

    for (const sec of sections) {
      if (!hasNonEmpty(sec.content)) continue;
      const id = `sec-${idx++}`;
      const inner = sec.content
        .filter(l => (l||"").trim() !== "")
        .map(l => `<div class="answer-line">${escapeHtml(l.trim())}</div>`)
        .join("");

      const alwaysOpen = (sec.title === "Summary");

      if (alwaysOpen) {
        html += `
          <div class="section">
            <div class="section-header static">
              <span>${escapeHtml(sec.title)}</span>
              <button class="section-copy-btn copy-btn" data-target="${id}" type="button">Copy</button>
            </div>
            <div class="section-body static-body" data-section="${id}">
              ${inner}
            </div>
          </div>`;
      } else {
        html += `
          <div class="section">
            <div class="collapsible-header">
              <button class="collapsible" data-target="${id}" type="button">${escapeHtml(sec.title)}</button>
              <button class="section-copy-btn copy-btn" data-target="${id}" type="button">Copy</button>
            </div>
            <div class="collapsible-content" data-section="${id}" style="display:none;">
              ${inner}
            </div>
          </div>`;
      }
    }

    return html || `<div class="answer-paragraph">${escapeHtml(text)}</div>`;
  }

  // Accordion click + copy
  document.addEventListener("click", async (e) => {
    const t = e.target;

    if (t.classList && t.classList.contains("collapsible")) {
      const id = t.dataset.target;
      const content = document.querySelector(`.collapsible-content[data-section="${id}"]`);
      if (!content) return;
      const open = content.style.display === "block";
      content.style.display = open ? "none" : "block";
      t.classList.toggle("active", !open);
      return;
    }

    if (t.classList && t.classList.contains("section-copy-btn")) {
      const id = t.dataset.target;
      const section = document.querySelector(`[data-section="${id}"]`);
      if (!section) return;
      const text = (section.innerText || "").trim();
      if (!text) return;
      await copyText(text);
      return;
    }

    // Smart device dropdown open/close
    if (t === connectDeviceBtn) {
      deviceMenuPanel.classList.toggle("open");
      return;
    }
    if (t.closest && t.closest("#deviceMenuPanel") && t.dataset.device) {
      const device = t.dataset.device;
      deviceMenuPanel.classList.remove("open");
      flashStatus(wrStatus, `Smart device selected: ${device} (placeholder).`);
      // If you have /api/device/connect, you can uncomment:
      // fetch("/api/device/connect",{method:"POST",headers:{ "Content-Type":"application/json" },body:JSON.stringify({device})});
      return;
    }
    if (!t.closest || (!t.closest(".device-menu"))) {
      deviceMenuPanel.classList.remove("open");
    }
  });

  // Corrections
  function loadCorrections(key){ return safeJsonParse(localStorage.getItem(key) || "{}", {}); }
  function saveCorrections(key, map){ localStorage.setItem(key, JSON.stringify(map || {})); }
  function applyCorrections(key, text){
    let out = text || "";
    const map = loadCorrections(key);
    const keys = Object.keys(map).sort((a,b)=>b.length-a.length);
    for (const k of keys) {
      const v = map[k];
      if (!k || !v) continue;
      const re = new RegExp(k.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
      out = out.replace(re, v);
    }
    return out;
  }
  function addCorrectionFromSelection(textarea, storeKey){
    const s = textarea.selectionStart;
    const e = textarea.selectionEnd;
    const selected = (textarea.value || "").slice(s, e).trim();
    if (!selected) { alert("Highlight the incorrect words first."); return; }
    const correct = prompt("What should it be instead?", selected);
    if (!correct || !correct.trim()) return;

    const map = loadCorrections(storeKey);
    map[selected] = correct.trim();
    saveCorrections(storeKey, map);

    const before = textarea.value.slice(0, s);
    const after = textarea.value.slice(e);
    textarea.value = before + correct.trim() + after;
  }

  incorrectQuestionBtn.addEventListener("click", () => addCorrectionFromSelection(clinicalQuestion, STORE_Q_CORR));
  incorrectWrBtn.addEventListener("click", () => addCorrectionFromSelection(wrNote, STORE_WR_CORR));

  // Sidebar storage
  function loadSavedQA(){ return safeJsonParse(localStorage.getItem(STORE_SAVED_QA) || "[]", []); }
  function saveSavedQA(list){ localStorage.setItem(STORE_SAVED_QA, JSON.stringify(list || [])); }

  function loadSavedNotes(){ return safeJsonParse(localStorage.getItem(STORE_SAVED_NOTES) || "[]", []); }
  function saveSavedNotes(list){ localStorage.setItem(STORE_SAVED_NOTES, JSON.stringify(list || [])); }

  function loadSavedHandovers(){ return safeJsonParse(localStorage.getItem(STORE_SAVED_HANDOVERS) || "[]", []); }
  function saveSavedHandovers(list){ localStorage.setItem(STORE_SAVED_HANDOVERS, JSON.stringify(list || [])); }

  function addSavedQA(question, answerText){
    const list = loadSavedQA();
    const title = question.length > 60 ? question.slice(0, 60).trim() + "‚Ä¶" : question.trim();
    list.unshift({ id: Date.now(), title, question, answer: answerText || "", ts: Date.now() });
    saveSavedQA(list.slice(0, 80));
  }

  function addSavedNote(content){
    const list = loadSavedNotes();
    const title = "Notes " + new Date().toLocaleString();
    list.unshift({ id: Date.now(), title, content, ts: Date.now() });
    saveSavedNotes(list.slice(0, 80));
  }

  function addSavedHandover(content){
    const list = loadSavedHandovers();
    const title = "Handover " + new Date().toLocaleString();
    list.unshift({ id: Date.now(), title, content, ts: Date.now() });
    saveSavedHandovers(list.slice(0, 80));
  }

  function renderSidebar(){
    const term = norm(sidebarSearch.value || "");

    // Q/A
    const qa = loadSavedQA();
    savedQuestionsList.innerHTML = "";
    if (!qa.length) {
      savedQuestionsList.innerHTML = '<div class="conv-empty">No saved questions yet.</div>';
    } else {
      qa.forEach((item, idx) => {
        const show = !term || norm(item.title).includes(term) || norm(item.question).includes(term);
        if (!show) return;

        const row = document.createElement("div");
        row.className = "conversation-item";

        const main = document.createElement("div");
        main.className = "conv-main";
        main.innerHTML = `<div class="conv-title">${escapeHtml(item.title || "Question")}</div>`;

        const copy = document.createElement("button");
        copy.className = "conv-delete";
        copy.textContent = "‚ßâ";
        copy.title = "Copy Q+A";

        const del = document.createElement("button");
        del.className = "conv-delete";
        del.textContent = "‚úï";
        del.title = "Remove";

        main.addEventListener("click", () => {
          clinicalQuestion.value = item.question || "";
          answerEl.innerHTML = item.answer ? buildStructuredHtml(item.answer) : "Your answer will appear here.";
          copyAllBtn.disabled = !(item.answer || "").trim();
          sendToConsultBtn.disabled = !(item.answer || "").trim();
          clinicalQuestion.focus();
        });

        copy.addEventListener("click", async (e) => {
          e.stopPropagation();
          const out = `Q: ${item.question || ""}\n\nA:\n${item.answer || ""}`.trim();
          if (out) await copyText(out);
        });

        del.addEventListener("click", (e) => {
          e.stopPropagation();
          const list = loadSavedQA();
          list.splice(idx, 1);
          saveSavedQA(list);
          renderSidebar();
        });

        row.appendChild(main);
        row.appendChild(copy);
        row.appendChild(del);
        savedQuestionsList.appendChild(row);
      });
    }

    // Notes
    const notes = loadSavedNotes();
    savedWrList.innerHTML = "";
    if (!notes.length) {
      savedWrList.innerHTML = '<div class="conv-empty">No saved notes yet.</div>';
    } else {
      notes.forEach((item, idx) => {
        const show = !term || norm(item.title).includes(term) || norm(item.content).includes(term);
        if (!show) return;

        const row = document.createElement("div");
        row.className = "conversation-item";

        const main = document.createElement("div");
        main.className = "conv-main";
        main.innerHTML = `<div class="conv-title">${escapeHtml(item.title || "Notes")}</div>`;

        const copy = document.createElement("button");
        copy.className = "conv-delete";
        copy.textContent = "‚ßâ";
        copy.title = "Copy note";

        const del = document.createElement("button");
        del.className = "conv-delete";
        del.textContent = "‚úï";
        del.title = "Remove";

        main.addEventListener("click", () => {
          wrNote.value = item.content || "";
          wrNote.focus();
        });

        copy.addEventListener("click", async (e) => {
          e.stopPropagation();
          if ((item.content || "").trim()) await copyText(item.content.trim());
        });

        del.addEventListener("click", (e) => {
          e.stopPropagation();
          const list = loadSavedNotes();
          list.splice(idx, 1);
          saveSavedNotes(list);
          renderSidebar();
        });

        row.appendChild(main);
        row.appendChild(copy);
        row.appendChild(del);
        savedWrList.appendChild(row);
      });
    }

    // Handovers
    const handovers = loadSavedHandovers();
    savedHandoverList.innerHTML = "";
    if (!handovers.length) {
      savedHandoverList.innerHTML = '<div class="conv-empty">No saved handovers yet.</div>';
    } else {
      handovers.forEach((item, idx) => {
        const show = !term || norm(item.title).includes(term) || norm(item.content).includes(term);
        if (!show) return;

        const row = document.createElement("div");
        row.className = "conversation-item";

        const main = document.createElement("div");
        main.className = "conv-main";
        main.innerHTML = `<div class="conv-title">${escapeHtml(item.title || "Handover")}</div>`;

        const copy = document.createElement("button");
        copy.className = "conv-delete";
        copy.textContent = "‚ßâ";
        copy.title = "Copy handover";

        const del = document.createElement("button");
        del.className = "conv-delete";
        del.textContent = "‚úï";
        del.title = "Remove";

        main.addEventListener("click", () => {
          wrOutput.value = item.content || "";
          wrOutput.focus();
        });

        copy.addEventListener("click", async (e) => {
          e.stopPropagation();
          if ((item.content || "").trim()) await copyText(item.content.trim());
        });

        del.addEventListener("click", (e) => {
          e.stopPropagation();
          const list = loadSavedHandovers();
          list.splice(idx, 1);
          saveSavedHandovers(list);
          renderSidebar();
        });

        row.appendChild(main);
        row.appendChild(copy);
        row.appendChild(del);
        savedHandoverList.appendChild(row);
      });
    }
  }

  sidebarSearch.addEventListener("input", renderSidebar);

// === Consultation generate ===
async function generateConsult() {
  const input = (wrNote.value || "").trim();
  if (!input) return;

  const cmode = consultModeSelect?.value || "consult_note";

  consultGenerateBtn.disabled = true;

  // ‚úÖ Correct loader (Consultation section only)
  wrAnswerLoader?.classList.remove("hidden");

  try {
    const res = await fetch("/api/consult", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: input, mode: cmode })
    });

    const data = await res.json();

    if (data.answer) {
      wrOutput.value = data.answer || "";
      flashStatus(wrStatus, "Generated.");
    } else {
      wrOutput.value = "";
      flashStatus(wrStatus, (data.error || "Generate failed.").trim());
    }

  } catch (e) {
    console.error(e);
    wrOutput.value = "";
    flashStatus(wrStatus, "Generate error.");
  } finally {
    // ‚úÖ Hide consult loader
    wrAnswerLoader?.classList.add("hidden");
    consultGenerateBtn.disabled = false;
  }
}

if (generateBtn) {
  generateBtn.addEventListener("click", generateClinical);
}

if (clinicalQuestion) {
  clinicalQuestion.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      generateClinical();
    }
  });
}

  copyAllBtn.addEventListener("click", async () => {
    const text = (answerEl.innerText || "").trim();
    if (!text) return;
    await copyText(text);
  });

  sendToConsultBtn.addEventListener("click", () => {
    const text = (answerEl.innerText || "").trim();
    if (!text) return;
    wrOutput.value = text;
    flashStatus(wrStatus, "Sent to Consult output.");
  });

  // Clear saves Q+A
  clearQuestionBtn.addEventListener("click", () => {
    const q = (clinicalQuestion.value || "").trim();
    const a = (answerEl.innerText || "").trim();
    if (q && a) addSavedQA(q, a);

    clinicalQuestion.value = "";
    answerEl.innerHTML = "Your answer will appear here.";
    copyAllBtn.disabled = true;
    sendToConsultBtn.disabled = true;
    flashStatus(qStatus, "Cleared (saved).");
    renderSidebar();
  });
// === Clinical Answer generate ===
async function generateClinical() {
  const input = (clinicalQuestion?.value || "").trim();
  if (!input) return;

  try {
    generateBtn.disabled = true;

    const res = await fetch("/api/clinical", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: input })
    });

    const data = await res.json();

    if (data.answer) {
      answerEl.innerText = data.answer;
      copyAllBtn.disabled = false;
      sendToConsultBtn.disabled = false;
    } else {
      answerEl.innerText = data.error || "Generate failed.";
    }
  } catch (e) {
    console.error(e);
    answerEl.innerText = "Generate error.";
  } finally {
    generateBtn.disabled = false;
  }
}
  // === Consultation generate ===
async function generateConsult() {
  const input = (wrNote.value || "").trim();
  if (!input) return;

  const cmode = consultModeSelect?.value || "consult_note";

  consultGenerateBtn.disabled = true;

  // ‚úÖ show loader in Consultation Notes section (not Clinical Answers)
  wrAnswerLoader?.classList.remove("hidden");

  // optional: prevent double inputs while generating
  // wrNote.disabled = true;

  try {
    const res = await fetch("/api/consult", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: input, mode: cmode })
    });

    const data = await res.json();

    if (data.answer) {
      wrOutput.value = data.answer || "";
      flashStatus(wrStatus, "Generated.");
    } else {
      wrOutput.value = "";
      flashStatus(wrStatus, (data.error || "Generate failed.").trim());
    }
  } catch (e) {
    console.error(e);
    wrOutput.value = "";
    flashStatus(wrStatus, "Generate error.");
  } finally {
    // ‚úÖ hide consult loader
    wrAnswerLoader?.classList.add("hidden");
    consultGenerateBtn.disabled = false;

    // wrNote.disabled = false;
  }
}

consultGenerateBtn.addEventListener("click", generateConsult);

// Enter = Generate in notes, Shift+Enter newline
wrNote.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    generateConsult();
  }
});

  // Copy includes input + output
  copyWrBtn.addEventListener("click", async () => {
    const input = (wrNote.value || "").trim();
    const output = (wrOutput.value || "").trim();
    const payload = output ? `INPUT:\n${input}\n\nOUTPUT:\n${output}`.trim() : input;
    if (!payload.trim()) return;
    await copyText(payload);
    flashStatus(wrStatus, "Copied.");
  });

  saveWrBtn.addEventListener("click", () => {
    const cmode = consultModeSelect?.value || "consult_note";
    const input = (wrNote.value || "").trim();
    const output = (wrOutput.value || "").trim();
    const archiveText = output ? `INPUT:\n${input}\n\nOUTPUT:\n${output}`.trim() : input;
    if (!archiveText.trim()) return;

    if (cmode === "handover") addSavedHandover(archiveText);
    else addSavedNote(archiveText);

    flashStatus(wrStatus, "Saved.");
    renderSidebar();
  });

  newWrBtn.addEventListener("click", () => {
    const current = ((wrNote.value || "").trim() || (wrOutput.value || "").trim());
    if (current) {
      const save = confirm("Save this before starting a new one?");
      if (save) {
        const cmode = consultModeSelect?.value || "consult_note";
        const archiveText = `INPUT:\n${(wrNote.value||"").trim()}\n\nOUTPUT:\n${(wrOutput.value||"").trim()}`.trim();
        if (cmode === "handover") addSavedHandover(archiveText);
        else addSavedNote(archiveText);
      }
    }
    wrNote.value = "";
    wrOutput.value = "";
    flashStatus(wrStatus, "Cleared.");
    renderSidebar();
  });

  // Dictation: uses your existing /api/transcribe route
  function pickMimeType(){
    const candidates = ["audio/webm;codecs=opus", "audio/webm", "audio/ogg;codecs=opus", "audio/ogg"];
    for (const t of candidates) {
      if (window.MediaRecorder?.isTypeSupported?.(t)) return t;
    }
    return "";
  }

  async function ensureMicPermission(statusEl){
    if (!window.isSecureContext) { flashStatus(statusEl, "Mic error: must be HTTPS."); return false; }
    if (!navigator.mediaDevices?.getUserMedia) { flashStatus(statusEl, "Mic error: unsupported."); return false; }
    try {
      const s = await navigator.mediaDevices.getUserMedia({ audio: true });
      s.getTracks().forEach(t => t.stop());
      return true;
    } catch (e) {
      console.warn(e);
      flashStatus(statusEl, "Mic blocked: allow microphone permission.");
      return false;
    }
  }

  function dedupeRepeats(text){
    if (!text) return "";
    let t = String(text);
    t = t.replace(/\b(\w+)(\s+\1){2,}\b/gi, "$1");
    t = t.replace(/\s{2,}/g, " ").trim();
    return t;
  }
  function normaliseDictation(text){
    let t = dedupeRepeats(text);
    t = t.replace(/\b(um|uh|like|you know)\b/gi, "");
    t = t.replace(/\s{2,}/g, " ").trim();
    return t;
  }

  async function transcribeBlob(blob){
    const form = new FormData();
    form.append("audio", blob, "audio.webm");
    const res = await fetch("/api/transcribe", { method: "POST", body: form });
    const raw = await res.text();
    let data = {};
    try { data = JSON.parse(raw); } catch {}
    if (!res.ok) throw new Error(data.error || raw || ("HTTP " + res.status));
    return (data.text || "").trim();
  }

  function createRecorderController({ statusEl, onText }){
    let stream = null;
    let recorder = null;
    let chunks = [];
    let recording = false;

    async function start(){
      if (recording) return;
      recording = true;
      chunks = [];



      flashStatus(statusEl, "Mic: starting‚Ä¶");

      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mimeType = pickMimeType();
      recorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);

      recorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) chunks.push(e.data); };
      recorder.onstart = () => flashStatus(statusEl, "Mic: recording‚Ä¶");
      recorder.onstop = async () => {
        try {
          flashStatus(statusEl, "Mic: transcribing‚Ä¶");
          const blob = new Blob(chunks, { type: recorder.mimeType || "audio/webm" });
          if (!blob || blob.size < 300) { flashStatus(statusEl, "Mic: no audio detected."); return; }
          const textRaw = await transcribeBlob(blob);
          const textClean = normaliseDictation(textRaw);
          if (textClean) onText(textClean);
          flashStatus(statusEl, "Mic: done.");
        } catch (e) {
          console.warn(e);
          flashStatus(statusEl, "Mic: transcribe failed.");
        } finally {
          try { stream?.getTracks()?.forEach(t => t.stop()); } catch {}
          stream = null; recorder = null; chunks = []; recording = false;
        }
      };

      recorder.start();
    }

    function stop(){
      if (!recording || !recorder) return;
      flashStatus(statusEl, "Mic: stopping‚Ä¶");
      try { recorder.stop(); } catch(e) {}
    }

    return { start, stop, isRecording: () => recording };
  }

  let qRecorder = null;
  let nRecorder = null;

  async function initRecordersIfNeeded(){
    if (!qRecorder) {
      qRecorder = createRecorderController({
        statusEl: qStatus,
        onText: (text) => {
          const fixed = applyCorrections(STORE_Q_CORR, text).trim();
          clinicalQuestion.value = fixed;
          flashStatus(qStatus, "Question captured.");
        }
      });
    }
    if (!nRecorder) {
      nRecorder = createRecorderController({
        statusEl: wrStatus,
        onText: (text) => {
          const fixed = applyCorrections(STORE_WR_CORR, text).trim();
          if (!fixed) return;
          const current = (wrNote.value || "").trim();
          wrNote.value = current ? (current + "\n" + fixed) : fixed;
          flashStatus(wrStatus, "Notes captured.");
        }
      });
    }
  }

  dictateQuestionBtn.addEventListener("click", async () => {
    const ok = await ensureMicPermission(qStatus);
    if (!ok) return;
    await initRecordersIfNeeded();

    if (!qRecorder.isRecording()) { dictateQuestionBtn.textContent = "‚èπ Stop"; qRecorder.start(); }
    else { dictateQuestionBtn.textContent = "üéô Dictate"; qRecorder.stop(); }
  });

  dictateWrBtn.addEventListener("click", async () => {
    const ok = await ensureMicPermission(wrStatus);
    if (!ok) return;
    await initRecordersIfNeeded();

    if (!nRecorder.isRecording()) { dictateWrBtn.textContent = "‚èπ Stop"; nRecorder.start(); }
    else { dictateWrBtn.textContent = "üéô Dictate"; nRecorder.stop(); }
  });

  // Init
  renderSidebar();
  flashStatus(qStatus, "Ready. Enter=Generate, Shift+Enter=new line.");
  flashStatus(wrStatus, "Notes mic: idle.");
});
</script>

</body>
</html>
