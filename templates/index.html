<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clinical Engine | EBM Session</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
  <div class="app-root">
    <div class="shell">
      <div class="layout">
        <aside class="sidebar">
          <div class="sidebar-header">
            <div class="sidebar-brand">
              <div class="brand-logo"></div>
              <div class="brand-text">
                <div class="brand-title">EBM</div>
                <div class="sidebar-title">EBM Session</div>
              </div>
            </div>
            <input id="topicSearch" class="topic-search" type="text" placeholder="Search topics..." />
          </div>
          <div id="conversationList" class="conversation-list"></div>
          <div class="sidebar-footer">
            <span class="sidebar-hint">Locally stored ‚Ä¢ Per device</span>
          </div>
        </aside>

        <div class="main-region">
          <header class="header">
            <h1 class="title">CLINICAL ENGINE</h1>
            <p class="subtitle">Enter a clinical question to generate an evidence-based answer.</p>
          </header>

          <main class="grid">
            <section class="card input-card">
              <label class="label" for="question">Clinical Question</label>
              <textarea id="question" class="textarea" rows="6"></textarea>
              <div class="actions">
                <button id="generateBtn" class="btn">Generate</button>
              </div>
            </section>

            <section class="card output-card">
              <div class="output-header">
                <h2 class="output-title">Answers</h2>
              </div>

              <div id="answerLoader" class="answer-loader hidden">
                <div class="loader"></div>
                <div class="loader-text">Generating structured answer‚Ä¶</div>
              </div>

              <div class="output-body">
                <div id="answer" class="answer placeholder">
                  Hold the mic button to speak.
                </div>
              </div>
            </section>
          </main>
        </div>
      </div>
    </div>
  </div>

  <!-- Floating mic button (hold to record) -->
  <button id="micBtn" aria-label="Hold to record" type="button"
    style="
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 64px;
      height: 64px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      z-index: 9999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
      font-size: 26px;
      line-height: 64px;
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    ">üéôÔ∏è</button>

<script>
/* =========================================================
   CORE GENERATE
   ========================================================= */
const questionInput = document.getElementById("question");
const generateBtn = document.getElementById("generateBtn");
const answerEl = document.getElementById("answer");
const answerLoader = document.getElementById("answerLoader");

function setStatus(msg) {
  answerEl.classList.remove("placeholder");
  answerEl.textContent = msg;
}

async function generate() {
  const query = questionInput.value.trim();
  if (!query) return;

  answerLoader.classList.remove("hidden");
  answerEl.textContent = "";

  try {
    const res = await fetch("/api/generate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query })
    });
    const data = await res.json();
    answerEl.textContent = data.answer || data.error || "No response.";
  } catch (e) {
    console.error(e);
    answerEl.textContent = "Error generating answer.";
  } finally {
    answerLoader.classList.add("hidden");
  }
}

generateBtn.addEventListener("click", generate);

questionInput.addEventListener("keydown", e => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    generate();
  }
});

/* =========================================================
   MOBILE + DESKTOP HOLD-TO-TALK
   ========================================================= */
const micBtn = document.getElementById("micBtn");

let stream = null;
let mediaRecorder = null;
let audioChunks = [];
let recording = false;
let startAt = 0;

function pickMimeType() {
  const candidates = [
    "audio/webm;codecs=opus",
    "audio/webm",
    "audio/ogg;codecs=opus",
    "audio/ogg"
  ];
  for (const t of candidates) {
    if (window.MediaRecorder && window.MediaRecorder.isTypeSupported && window.MediaRecorder.isTypeSupported(t)) {
      return t;
    }
  }
  return "";
}

async function startRecording() {
  if (recording) return;

  if (!navigator.mediaDevices?.getUserMedia) {
    setStatus("Voice: your browser does not support microphone recording.");
    return;
  }
  if (!window.MediaRecorder) {
    setStatus("Voice: MediaRecorder not supported. (Some iPhones/iOS versions.)");
    return;
  }

  recording = true;
  audioChunks = [];
  startAt = Date.now();

  micBtn.textContent = "üî¥";

  try {
    setStatus("Voice: requesting microphone permission‚Ä¶");
    stream = await navigator.mediaDevices.getUserMedia({ audio: true });

    const mt = pickMimeType();
    mediaRecorder = mt ? new MediaRecorder(stream, { mimeType: mt }) : new MediaRecorder(stream);

    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size > 0) audioChunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      try {
        micBtn.textContent = "üéôÔ∏è";

        // stop tracks
        if (stream) stream.getTracks().forEach(t => t.stop());
        stream = null;

        const durationMs = Date.now() - startAt;
        if (durationMs < 350) {
          setStatus("Voice: too short. Hold the mic button and speak, then release.");
          return;
        }

        const blob = new Blob(audioChunks, { type: mediaRecorder?.mimeType || "audio/webm" });
        audioChunks = [];
        mediaRecorder = null;

        if (!blob || blob.size < 2500) {
          setStatus("Voice: too quiet/short. Try again closer to the mic.");
          return;
        }

        setStatus("Voice: transcribing‚Ä¶");

        const form = new FormData();
        form.append("audio", blob, "speech.webm");

        const res = await fetch("/api/transcribe", { method: "POST", body: form });
        const data = await res.json();

        const text = (data.text || "").trim();
        if (!text) {
          setStatus("Voice: no text recognised. Try again.");
          return;
        }

        questionInput.value = text;
        setStatus("Voice captured ‚Äî generating‚Ä¶");
        setTimeout(() => generateBtn.click(), 150);

      } catch (e) {
        console.error(e);
        setStatus("Voice: transcription failed.");
      } finally {
        recording = false;
        micBtn.textContent = "üéôÔ∏è";
      }
    };

    mediaRecorder.start();
    setStatus("Voice: recording‚Ä¶ release to send");

  } catch (e) {
    console.warn(e);
    recording = false;
    micBtn.textContent = "üéôÔ∏è";
    setStatus("Voice: microphone blocked. Enable mic permission for this site and refresh.");
  }
}

function stopRecording() {
  if (!recording) return;
  try {
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      mediaRecorder.stop();
    }
  } catch (e) {
    console.warn(e);
    recording = false;
    micBtn.textContent = "üéôÔ∏è";
    setStatus("Voice: stop failed. Try again.");
  }
}

/* ---- Desktop (mouse) ---- */
micBtn.addEventListener("mousedown", (e) => {
  e.preventDefault();
  startRecording();
});
document.addEventListener("mouseup", (e) => {
  if (recording) stopRecording();
});

/* ---- Mobile (touch) ---- */
micBtn.addEventListener("touchstart", (e) => {
  e.preventDefault(); // prevents long-press menu + scrolling issues
  startRecording();
}, { passive: false });

micBtn.addEventListener("touchend", (e) => {
  e.preventDefault();
  stopRecording();
}, { passive: false });

micBtn.addEventListener("touchcancel", (e) => {
  e.preventDefault();
  stopRecording();
}, { passive: false });

window.addEventListener("DOMContentLoaded", () => {
  setStatus("Hold the mic button, speak, then release.");
});
</script>

</body>
</html>
