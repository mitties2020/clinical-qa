<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clinical Q&A Engine | EBM Nexus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <div class="app-root">
    <div class="shell">
      <header class="header">
        <h1 class="title">Clinical Q&amp;A Engine</h1>
        <p class="subtitle">
          Enter a clinical question to generate an evidence based answer.
        </p>
      </header>

      <main class="grid">
        <!-- LEFT: INPUT -->
        <section class="card input-card">
          <label class="label" for="question">Clinical question</label>
          <textarea
            id="question"
            class="textarea"
            rows="6"
            placeholder="e.g. Evidence-based management of new-onset atrial fibrillation in a haemodynamically stable adult?"
          ></textarea>

          <div class="actions">
            <button id="generateBtn" class="btn">Generate</button>
            <span class="hint">
              Enter = generate • Shift+Enter = newline
            </span>
          </div>
        </section>

        <!-- RIGHT: OUTPUT -->
        <section class="card output-card">
          <div class="output-header">
            <h2 class="output-title">Answer</h2>
            <button id="copyBtn" class="copy-btn" disabled>Copy</button>
          </div>

          <!-- Loading overlay -->
          <div id="answerLoader" class="answer-loader hidden">
            <div class="loader"></div>
            <div class="loader-text">Generating structured answer…</div>
          </div>

          <div class="output-body">
            <div id="answer" class="answer placeholder">
              Your structured, evidence-based response will appear here.
            </div>
          </div>
        </section>
      </main>
    </div>
  </div>

  <script>
    const questionInput = document.getElementById("question");
    const generateBtn = document.getElementById("generateBtn");
    const answerEl = document.getElementById("answer");
    const copyBtn = document.getElementById("copyBtn");
    const answerLoader = document.getElementById("answerLoader");

    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    // Parse the model output into sections + nested detail for Treatment/Management
    function buildStructuredHtml(raw) {
      if (!raw) return "";

      // Clean markdown-style noise
      let text = raw
        .replace(/\*\*(.*?)\*\*/g, "$1")
        .replace(/#{1,6}\s*/g, "")
        .replace(/\r/g, "");

      const lines = text.split("\n");

      const sectionOrder = [
        "Summary",
        "Assessment",
        "Investigations",
        "Treatment",
        "Management", // fallback if model uses "Management"
        "Monitoring",
        "Follow-up & Safety Netting",
        "Follow-up",
        "Red Flags",
        "References"
      ];

      const sections = [];
      let current = { title: "Summary", content: [] };
      let seenExplicitHeading = false;

      const isHeadingLine = (line) => {
        const trimmed = line.trim();
        const match = sectionOrder.find(
          (h) => trimmed.toLowerCase() === (h + ":").toLowerCase()
        );
        return match || null;
      };

      for (let rawLine of lines) {
        const line = rawLine.trim();
        if (!line) {
          current.content.push("");
          continue;
        }

        const heading = isHeadingLine(line);
        if (heading) {
          if (current.content.length > 0 || sections.length > 0) {
            sections.push(current);
          }
          current = { title: heading, content: [] };
          seenExplicitHeading = true;
        } else {
          current.content.push(line);
        }
      }
      if (current.content.length > 0) {
        sections.push(current);
      }

      // If no explicit headings were found, treat everything as Summary
      if (!seenExplicitHeading && sections.length === 1 && sections[0].title === "Summary") {
        return (
          `<div class="section">` +
          `<div class="section-header static">Summary</div>` +
          `<div class="section-body static-body">` +
          `<p>${escapeHtml(sections[0].content.join(" ").trim())}</p>` +
          `</div></div>`
        );
      }

      // Build HTML with collapsibles
      let html = "";

      sections.forEach((sec, index) => {
        const title = sec.title;
        const bodyLines = sec.content;

        if (!bodyLines || bodyLines.join("").trim() === "") return;

        // Summary always expanded at top
        if (title === "Summary" && index === 0) {
          html += `<div class="section">`;
          html += `<div class="section-header static">Summary</div>`;
          html += `<div class="section-body static-body">`;
          bodyLines.forEach((ln) => {
            const t = ln.trim();
            if (!t) return;
            html += `<p>${escapeHtml(t)}</p>`;
          });
          html += `</div></div>`;
          return;
        }

        // Collapsible sections for the rest
        html += `<div class="section">`;
        html += `<button class="collapsible">${escapeHtml(title)}</button>`;
        html += `<div class="collapsible-content">`;

        if (
          title === "Treatment" ||
          title === "Management"
        ) {
          html += buildTreatmentContent(bodyLines);
        } else {
          bodyLines.forEach((ln) => {
            const t = ln.trim();
            if (!t) {
              html += `<div class="spacer"></div>`;
              return;
            }

            // Simple bullets
            if (/^[-•]\s+/.test(t)) {
              html += `<div class="answer-bullet">• ${escapeHtml(t.replace(/^[-•]\s+/, ""))}</div>`;
            } else if (/^\d+[\.\)]\s+/.test(t)) {
              html += `<div class="answer-bullet">• ${escapeHtml(t.replace(/^\d+[\.\)]\s+/, ""))}</div>`;
            } else {
              html += `<p class="answer-paragraph">${escapeHtml(t)}</p>`;
            }
          });
        }

        html += `</div></div>`;
      });

      return html || "No response generated.";
    }

    // Build nested clickable options for Treatment/Management
    function buildTreatmentContent(lines) {
      let html = "";
      let currentOption = null;

      const flushOption = () => {
        if (currentOption) {
          const label = escapeHtml(currentOption.label);
          const content = escapeHtml(currentOption.details.join(" ").trim());
          html += `
            <div class="nested-block">
              <button class="nested-toggle">${label}</button>
              <div class="nested-content">
                <p>${content}</p>
              </div>
            </div>
          `;
        }
      };

      lines.forEach((raw) => {
        const line = raw.trim();
        if (!line) return;

        // Detect "Option: ..." lines
        if (/^Option:\s*/i.test(line)) {
          flushOption();
          const label = line.replace(/^Option:\s*/i, "").trim() || "Option";
          currentOption = { label, details: [] };
        } else if (/^Detail:\s*/i.test(line)) {
          const text = line.replace(/^Detail:\s*/i, "").trim();
          if (!currentOption) {
            currentOption = { label: "Detail", details: [] };
          }
          if (text) currentOption.details.push(text);
        } else if (/^[-•]\s+/.test(line) || /^\d+[\.\)]\s+/.test(line)) {
          // Bullet under treatment
          const cleaned = line
            .replace(/^[-•]\s+/, "")
            .replace(/^\d+[\.\)]\s+/, "");
          if (!currentOption) {
            // treat as general treatment bullet
            html += `<div class="answer-bullet">• ${escapeHtml(cleaned)}</div>`;
          } else {
            currentOption.details.push(cleaned);
          }
        } else {
          // Plain text: attach to current option or as paragraph
          if (currentOption) {
            currentOption.details.push(line);
          } else {
            html += `<p class="answer-paragraph">${escapeHtml(line)}</p>`;
          }
        }
      });

      flushOption();

      if (!html.trim()) {
        // fallback: if parsing failed, dump raw
        html = lines
          .map((l) => `<p class="answer-paragraph">${escapeHtml(l)}</p>`)
          .join("");
      }

      return html;
    }

    async function generate() {
      const query = questionInput.value.trim();
      if (!query) return;

      generateBtn.disabled = true;
      copyBtn.disabled = true;
      answerLoader.classList.remove("hidden");
      answerEl.classList.remove("placeholder");
      answerEl.innerHTML = "";

      try {
        const res = await fetch("/api/generate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query }),
        });

        const data = await res.json();

        if (data.answer) {
          const structured = buildStructuredHtml(data.answer);
          answerEl.innerHTML = structured;
        } else {
          answerEl.textContent = data.error || "No response generated.";
        }

        copyBtn.disabled = !answerEl.textContent.trim();
      } catch (err) {
        console.error(err);
        answerEl.textContent = "Error generating answer.";
        copyBtn.disabled = true;
      } finally {
        generateBtn.disabled = false;
        answerLoader.classList.add("hidden");
      }
    }

    // Click generate
    generateBtn.addEventListener("click", generate);

    // Enter = generate, Shift+Enter = newline
    questionInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        generate();
      }
    });

    // Copy plain text
    copyBtn.addEventListener("click", async () => {
      const text = answerEl.textContent.trim();
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        const original = copyBtn.textContent;
        copyBtn.textContent = "Copied";
        setTimeout(() => (copyBtn.textContent = original), 1500);
      } catch (err) {
        console.error(err);
      }
    });

    // Collapsible behavior (top-level + nested)
    document.addEventListener("click", (e) => {
      if (e.target.classList.contains("collapsible")) {
        e.target.classList.toggle("active");
        const content = e.target.nextElementSibling;
        if (!content) return;
        content.style.display =
          content.style.display === "block" ? "none" : "block";
      }

      if (e.target.classList.contains("nested-toggle")) {
        e.target.classList.toggle("active");
        const content = e.target.nextElementSibling;
        if (!content) return;
        content.style.display =
          content.style.display === "block" ? "none" : "block";
      }
    });
  </script>
</body>
</html>
