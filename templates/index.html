<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clinical Engine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
  <div class="app-root">
    <div class="shell">
      <div class="layout">

        <!-- SIDEBAR -->
        <aside class="sidebar">
          <div class="sidebar-header">
            <div class="sidebar-brand">
              <div class="brand-logo"></div>
              <div class="brand-text">
                <div class="brand-title">EBM</div>
                <div class="sidebar-title">Clinical Engine</div>
              </div>
            </div>

            <input id="sidebarSearch" class="topic-search" type="text" placeholder="Search saved..." />
          </div>

          <div class="sidebar-subhead">Saved Clinical Questions</div>
          <div id="savedQuestionsList" class="conversation-list"></div>

          <div class="sidebar-subhead">Consultation Notes (saved)</div>
          <div id="savedWrList" class="conversation-list"></div>

          <div class="sidebar-footer">
            <span class="sidebar-hint">Locally stored ‚Ä¢ Per device</span>
          </div>
        </aside>

        <!-- MAIN -->
        <div class="main-region">
          <header class="header">
            <h1 class="title">CLINICAL ENGINE</h1>
            <p class="subtitle">Clinical questions (top) + consultation notes (below). Dictation never triggers the Clinical Engine.</p>
          </header>

          <!-- TOP ROW -->
          <main class="grid">
            <!-- QUESTION -->
            <section class="card input-card">
              <label class="label" for="clinicalQuestion">Clinical Question</label>

              <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                <label class="label" style="margin:0;">Mode</label>
                <select id="modeSelect" class="topic-search" style="max-width:220px;">
                  <option value="clinical" selected>Clinical</option>
                  <option value="dva">DVA Referral Check</option>
                </select>
              </div>

              <textarea
                id="clinicalQuestion"
                class="textarea"
                rows="7"
                placeholder="Enter clinical question OR paste DVA patient details. Enter = Generate, Shift+Enter = new line."
              ></textarea>

              <div class="actions actions-compact">
                <button id="generateBtn" class="btn btn-compact" type="button">Generate</button>
                <button id="dictateQuestionBtn" class="btn btn-compact" type="button">üéô Dictate</button>
                <button id="incorrectQuestionBtn" class="btn btn-compact" type="button">Incorrect</button>
                <button id="clearQuestionBtn" class="btn btn-compact" type="button">Clear</button>
              </div>

              <div id="qStatus" class="mic-status">Question mic: idle</div>
            </section>

            <!-- ANSWER -->
            <section class="card output-card">
              <div class="output-header">
                <h2 class="output-title">Answers</h2>
                <button id="copyAllBtn" class="copy-btn main-copy-btn" disabled type="button">Copy All</button>
              </div>

              <div id="answerLoader" class="answer-loader hidden">
                <div class="loader"></div>
                <div class="loader-text">Generating structured answer‚Ä¶</div>
              </div>

              <div class="output-body">
                <div id="answer" class="answer placeholder">Your answer will appear here.</div>
              </div>
            </section>
          </main>

          <div class="divider-spacer"></div>

          <!-- CONSULTATION NOTES -->
          <section class="card wr-card">
            <div class="wr-head">
              <div>
                <div class="label wr-label">Consultation Notes</div>
                <div class="wr-sub">Dictation never triggers the Clinical Engine.</div>
              </div>

              <div class="actions actions-compact">
                <button id="dictateWrBtn" class="btn btn-compact" type="button">üéô Dictate</button>
                <button id="incorrectWrBtn" class="btn btn-compact" type="button">Incorrect</button>
                <button id="copyWrBtn" class="btn btn-compact" type="button">Copy</button>
                <button id="saveWrBtn" class="btn btn-compact" type="button">Save</button>
                <button id="newWrBtn" class="btn btn-compact" type="button">New</button>
              </div>
            </div>

            <textarea id="wrNote" class="textarea" rows="16" placeholder="Dictate or type freely here‚Ä¶"></textarea>
            <div id="wrStatus" class="mic-status">Notes mic: idle</div>
          </section>

        </div>
      </div>
    </div>
  </div>

<script>
window.addEventListener("DOMContentLoaded", () => {
  // Storage keys
  const STORE_Q_CORR = "ebm_q_corrections_v7";
  const STORE_WR_CORR = "ebm_wr_corrections_v7";
  const STORE_SAVED_QA = "ebm_saved_qa_v7";
  const STORE_SAVED_NOTES = "ebm_saved_notes_v7";

  // Elements
  const modeSelect = document.getElementById("modeSelect");

  const clinicalQuestion = document.getElementById("clinicalQuestion");
  const generateBtn = document.getElementById("generateBtn");
  const dictateQuestionBtn = document.getElementById("dictateQuestionBtn");
  const incorrectQuestionBtn = document.getElementById("incorrectQuestionBtn");
  const clearQuestionBtn = document.getElementById("clearQuestionBtn");

  const wrNote = document.getElementById("wrNote");
  const dictateWrBtn = document.getElementById("dictateWrBtn");
  const incorrectWrBtn = document.getElementById("incorrectWrBtn");
  const copyWrBtn = document.getElementById("copyWrBtn");
  const saveWrBtn = document.getElementById("saveWrBtn");
  const newWrBtn = document.getElementById("newWrBtn");

  const answerEl = document.getElementById("answer");
  const answerLoader = document.getElementById("answerLoader");
  const copyAllBtn = document.getElementById("copyAllBtn");

  const qStatus = document.getElementById("qStatus");
  const wrStatus =_cpu = document.getElementById("wrStatus");

  const savedQuestionsList = document.getElementById("savedQuestionsList");
  const savedWrList = document.getElementById("savedWrList");
  const sidebarSearch = document.getElementById("sidebarSearch");

  // Utils
  function norm(s) { return (s || "").toLowerCase().replace(/\s+/g, " ").trim(); }
  function escapeHtml(str) {
    return (str || "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
  }
  function safeJsonParse(s, fallback){ try { return JSON.parse(s); } catch { return fallback; } }
  async function copyText(text){ if (!text) return; try { await navigator.clipboard.writeText(text); } catch {} }
  function flashStatus(el, msg){ if (el) el.textContent = msg; }

  // Structured answer builder (collapsible)
  function hasNonEmpty(arr){ return Array.isArray(arr) && arr.some(l => (l||"").trim() !== ""); }

  function buildStructuredHtml(raw) {
    if (!raw) return "";
    let text = String(raw)
      .replace(/\r/g, "")
      .replace(/\*\*(.*?)\*\*/g, "$1")
      .replace(/#{1,6}\s*/g, "");

    const sectionOrder = [
      "Summary",
      "Assessment",
      "Diagnosis",
      "Investigations",
      "Treatment",
      "Monitoring",
      "Follow-up & Safety Netting",
      "Red Flags",
      "References",
    ];

    const lines = text.split("\n");
    const sections = [];
    let current = { title: "Summary", content: [] };
    let seenExplicit = false;

    function isHeading(line){
      const t = (line||"").trim().replace(/:$/, "");
      const match = sectionOrder.find(h => h.toLowerCase() === t.toLowerCase());
      return match || null;
    }

    for (const rawLine of lines) {
      const line = (rawLine||"").trim();
      if (!line) { current.content.push(""); continue; }
      const heading = isHeading(line);
      if (heading) {
        if (hasNonEmpty(current.content)) sections.push(current);
        current = { title: heading, content: [] };
        seenExplicit = true;
      } else {
        current.content.push(line);
      }
    }
    if (hasNonEmpty(current.content)) sections.push(current);

    if (!seenExplicit) {
      return `<div class="answer-paragraph">${escapeHtml(text)}</div>`;
    }

    let html = "";
    let idx = 0;

    for (const sec of sections) {
      if (!hasNonEmpty(sec.content)) continue;
      const id = `sec-${idx++}`;
      const inner = sec.content
        .filter(l => (l||"").trim() !== "")
        .map(l => `<p class="answer-paragraph">${escapeHtml(l.trim())}</p>`)
        .join("");

      const alwaysOpen = (sec.title === "Summary");

      if (alwaysOpen) {
        html += `
          <div class="section">
            <div class="section-header static">
              <span>${escapeHtml(sec.title)}</span>
              <button class="section-copy-btn copy-btn" data-target="${id}" type="button">Copy</button>
            </div>
            <div class="section-body static-body" data-section="${id}">
              ${inner}
            </div>
          </div>`;
      } else {
        html += `
          <div class="section">
            <div class="collapsible-header">
              <button class="collapsible" data-target="${id}" type="button">${escapeHtml(sec.title)}</button>
              <button class="section-copy-btn copy-btn" data-target="${id}" type="button">Copy</button>
            </div>
            <div class="collapsible-content" data-section="${id}" style="display:none;">
              ${inner}
            </div>
          </div>`;
      }
    }

    return html || `<div class="answer-paragraph">${escapeHtml(text)}</div>`;
  }

  document.addEventListener("click", async (e) => {
    const t = e.target;

    if (t.classList && t.classList.contains("collapsible")) {
      const id = t.dataset.target;
      const content = document.querySelector(`.collapsible-content[data-section="${id}"]`);
      if (!content) return;
      const open = content.style.display === "block";
      content.style.display = open ? "none" : "block";
      t.classList.toggle("active", !open);
      return;
    }

    if (t.classList && t.classList.contains("section-copy-btn")) {
      const id = t.dataset.target;
      const section = document.querySelector(`[data-section="${id}"]`);
      if (!section) return;
      const text = (section.innerText || "").trim();
      if (!text) return;
      await copyText(text);
      return;
    }
  });

  // Corrections
  function loadCorrections(key){ return safeJsonParse(localStorage.getItem(key) || "{}", {}); }
  function saveCorrections(key, map){ localStorage.setItem(key, JSON.stringify(map || {})); }
  function applyCorrections(key, text){
    let out = text || "";
    const map = loadCorrections(key);
    const keys = Object.keys(map).sort((a,b)=>b.length-a.length);
    for (const k of keys) {
      const v = map[k];
      if (!k || !v) continue;
      const re = new RegExp(k.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
      out = out.replace(re, v);
    }
    return out;
  }
  function addCorrectionFromSelection(textarea, storeKey){
    const s = textarea.selectionStart;
    const e = textarea.selectionEnd;
    const selected = (textarea.value || "").slice(s, e).trim();
    if (!selected) { alert("Highlight the incorrect words first."); return; }
    const correct = prompt("What should it be instead?", selected);
    if (!correct || !correct.trim()) return;

    const map = loadCorrections(storeKey);
    map[selected] = correct.trim();
    saveCorrections(storeKey, map);

    const before = textarea.value.slice(0, s);
    const after = textarea.value.slice(e);
    textarea.value = before + correct.trim() + after;
  }

  incorrectQuestionBtn.addEventListener("click", () => addCorrectionFromSelection(clinicalQuestion, STORE_Q_CORR));
  incorrectWrBtn.addEventListener("click", () => addCorrectionFromSelection(wrNote, STORE_WR_CORR));

  // Sidebar saved items
  function loadSavedQA(){ return safeJsonParse(localStorage.getItem(STORE_SAVED_QA) || "[]", []); }
  function saveSavedQA(list){ localStorage.setItem(STORE_SAVED_QA, JSON.stringify(list || [])); }
  function loadSavedNotes(){ return safeJsonParse(localStorage.getItem(STORE_SAVED_NOTES) || "[]", []); }
  function saveSavedNotes(list){ localStorage.setItem(STORE_SAVED_NOTES, JSON.stringify(list || [])); }

  function addSavedQA(question, answerText){
    const list = loadSavedQA();
    const title = question.length > 60 ? question.slice(0, 60).trim() + "‚Ä¶" : question.trim();
    list.unshift({ id: Date.now(), title, question, answer: answerText || "", ts: Date.now() });
    saveSavedQA(list.slice(0, 80));
  }

  function addSavedNote(content){
    const list = loadSavedNotes();
    const title = "Notes " + new Date().toLocaleString();
    list.unshift({ id: Date.now(), title, content, ts: Date.now() });
    saveSavedNotes(list.slice(0, 80));
  }

  function renderSidebar(){
    const term = norm(sidebarSearch.value || "");

    const qa = loadSavedQA();
    savedQuestionsList.innerHTML = "";
    if (!qa.length) {
      savedQuestionsList.innerHTML = '<div class="conv-empty">No saved questions yet.</div>';
    } else {
      qa.forEach((item, idx) => {
        const show = !term || norm(item.title).includes(term) || norm(item.question).includes(term);
        if (!show) return;

        const row = document.createElement("div");
        row.className = "conversation-item";

        const main = document.createElement("div");
        main.className = "conv-main";
        main.innerHTML = `<div class="conv-title">${escapeHtml(item.title || "Question")}</div>`;

        const copy = document.createElement("button");
        copy.className = "conv-delete";
        copy.textContent = "‚ßâ";
        copy.title = "Copy Q+A";

        const del = document.createElement("button");
        del.className = "conv-delete";
        del.textContent = "‚úï";
        del.title = "Remove";

        main.addEventListener("click", () => {
          clinicalQuestion.value = item.question || "";
          answerEl.innerHTML = item.answer ? buildStructuredHtml(item.answer) : "Your answer will appear here.";
          copyAllBtn.disabled = !(item.answer || "").trim();
          clinicalQuestion.focus();
        });

        copy.addEventListener("click", async (e) => {
          e.stopPropagation();
          const out = `Q: ${item.question || ""}\n\nA:\n${item.answer || ""}`.trim();
          if (out) await copyText(out);
        });

        del.addEventListener("click", (e) => {
          e.stopPropagation();
          const list = loadSavedQA();
          list.splice(idx, 1);
          saveSavedQA(list);
          renderSidebar();
        });

        row.appendChild(main);
        row.appendChild(copy);
        row.appendChild(del);
        savedQuestionsList.appendChild(row);
      });
    }

    const notes = loadSavedNotes();
    savedWrList.innerHTML = "";
    if (!notes.length) {
      savedWrList.innerHTML = '<div class="conv-empty">No saved notes yet.</div>';
    } else {
      notes.forEach((item, idx) => {
        const show = !term || norm(item.title).includes(term) || norm(item.content).includes(term);
        if (!show) return;

        const row = document.createElement("div");
        row.className = "conversation-item";

        const main = document.createElement("div");
        main.className = "conv-main";
        main.innerHTML = `<div class="conv-title">${escapeHtml(item.title || "Notes")}</div>`;

        const copy = document.createElement("button");
        copy.className = "conv-delete";
        copy.textContent = "‚ßâ";
        copy.title = "Copy note";

        const del = document.createElement("button");
        del.className = "conv-delete";
        del.textContent = "‚úï";
        del.title = "Remove";

        main.addEventListener("click", () => {
          wrNote.value = item.content || "";
          wrNote.focus();
        });

        copy.addEventListener("click", async (e) => {
          e.stopPropagation();
          if ((item.content || "").trim()) await copyText(item.content.trim());
        });

        del.addEventListener("click", (e) => {
          e.stopPropagation();
          const list = loadSavedNotes();
          list.splice(idx, 1);
          saveSavedNotes(list);
          renderSidebar();
        });

        row.appendChild(main);
        row.appendChild(copy);
        row.appendChild(del);
        savedWrList.appendChild(row);
      });
    }
  }

  sidebarSearch.addEventListener("input", renderSidebar);

  // Generate
  async function generate(){
    const query = (clinicalQuestion.value || "").trim();
    if (!query) return;

    const mode = (modeSelect && modeSelect.value) ? modeSelect.value : "clinical";

    generateBtn.disabled = true;
    copyAllBtn.disabled = true;
    answerLoader.classList.remove("hidden");
    answerEl.innerHTML = "";

    try {
      const res = await fetch("/api/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query, mode })
      });

      const data = await res.json();

      if (data.answer) {
        answerEl.innerHTML = buildStructuredHtml(data.answer);
        copyAllBtn.disabled = !(data.answer || "").trim();
        flashStatus(qStatus, "Generated.");
      } else {
        answerEl.textContent = (data.error || "No response.").trim();
        copyAllBtn.disabled = true;
        flashStatus(qStatus, "Generate failed.");
      }
    } catch (e) {
      console.error(e);
      answerEl.textContent = "Error generating answer.";
      copyAllBtn.disabled = true;
      flashStatus(qStatus, "Generate error.");
    } finally {
      answerLoader.classList.add("hidden");
      generateBtn.disabled = false;
    }
  }

  generateBtn.addEventListener("click", generate);

  // Enter = Generate, Shift+Enter = newline
  clinicalQuestion.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      generate();
    }
  });

  copyAllBtn.addEventListener("click", async () => {
    const text = (answerEl.innerText || "").trim();
    if (!text) return;
    await copyText(text);
  });

  // Clear saves Q+A to sidebar (if present)
  clearQuestionBtn.addEventListener("click", () => {
    const q = (clinicalQuestion.value || "").trim();
    const a = (answerEl.innerText || "").trim();
    if (q && a) addSavedQA(q, a);

    clinicalQuestion.value = "";
    answerEl.innerHTML = "Your answer will appear here.";
    copyAllBtn.disabled = true;
    flashStatus(qStatus, "Cleared (saved).");
    renderSidebar();
  });

  // Notes buttons
  copyWrBtn.addEventListener("click", async () => {
    const text = (wrNote.value || "").trim();
    if (!text) return;
    await copyText(text);
    flashStatus(wrStatus, "Copied.");
  });

  saveWrBtn.addEventListener("click", () => {
    const text = (wrNote.value || "").trim();
    if (!text) return;
    addSavedNote(text);
    flashStatus(wrStatus, "Saved.");
    renderSidebar();
  });

  newWrBtn.addEventListener("click", () => {
    const current = (wrNote.value || "").trim();
    if (current) {
      const save = confirm("Save this note before starting a new one?");
      if (save) addSavedNote(current);
    }
    wrNote.value = "";
    flashStatus(wrStatus, "Cleared.");
    renderSidebar();
  });

  // Dictation (MediaRecorder ‚Üí /api/transcribe)
  function pickMimeType(){
    const candidates = ["audio/webm;codecs=opus", "audio/webm", "audio/ogg;codecs=opus", "audio/ogg"];
    for (const t of candidates) {
      if (window.MediaRecorder?.isTypeSupported?.(t)) return t;
    }
    return "";
  }

  async function ensureMicPermission(statusEl){
    if (!window.isSecureContext) {
      flashStatus(statusEl, "Mic error: must be HTTPS.");
      return false;
    }
    if (!navigator.mediaDevices?.getUserMedia) {
      flashStatus(statusEl, "Mic error: getUserMedia unsupported.");
      return false;
    }
    try {
      const s = await navigator.mediaDevices.getUserMedia({ audio: true });
      s.getTracks().forEach(t => t.stop());
      return true;
    } catch (e) {
      console.warn(e);
      flashStatus(statusEl, "Mic blocked: allow microphone permission.");
      return false;
    }
  }

  function dedupeRepeats(text){
    if (!text) return "";
    let t = String(text);
    t = t.replace(/\b(\w+)(\s+\1){2,}\b/gi, "$1");
    t = t.replace(/\s{2,}/g, " ").trim();
    return t;
  }
  function normaliseDictation(text){
    let t = dedupeRepeats(text);
    t = t.replace(/\b(um|uh|like|you know)\b/gi, "");
    t = t.replace(/\s{2,}/g, " ").trim();
    return t;
  }

  async function transcribeBlob(blob){
    const form = new FormData();
    form.append("audio", blob, "audio.webm");
    const res = await fetch("/api/transcribe", { method: "POST", body: form });
    const raw = await res.text();

    let data = {};
    try { data = JSON.parse(raw); } catch {}
    if (!res.ok) throw new Error(data.error || raw || ("HTTP " + res.status));
    return (data.text || "").trim();
  }

  function createRecorderController({ statusEl, onText }){
    let stream = null;
    let recorder = null;
    let chunks = [];
    let recording = false;

    async function start(){
      if (recording) return;
      recording = true;
      chunks = [];

      flashStatus(statusEl, "Mic: starting‚Ä¶");
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      const mimeType = pickMimeType();
      recorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);

      recorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };

      recorder.onstart = () => flashStatus(statusEl, "Mic: recording‚Ä¶");

      recorder.onstop = async () => {
        try {
          flashStatus(statusEl, "Mic: transcribing‚Ä¶");
          const blob = new Blob(chunks, { type: recorder.mimeType || "audio/webm" });
          if (!blob || blob.size < 300) {
            flashStatus(statusEl, "Mic: no audio detected.");
            return;
          }
          const textRaw = await transcribeBlob(blob);
          const textClean = normaliseDictation(textRaw);
          if (textClean) onText(textClean);
          flashStatus(statusEl, "Mic: done.");
        } catch (e) {
          console.warn(e);
          flashStatus(statusEl, "Mic: transcribe failed.");
        } finally {
          try { stream?.getTracks()?.forEach(t => t.stop()); } catch {}
          stream = null;
          recorder = null;
          chunks = [];
          recording = false;
        }
      };

      recorder.start();
    }

    function stop(){
      if (!recording || !recorder) return;
      flashStatus(statusEl, "Mic: stopping‚Ä¶");
      try { recorder.stop(); } catch(e) {}
    }

    return { start, stop, isRecording: () => recording };
  }

  let qRecorder = null;
  let nRecorder = null;

  async function initRecordersIfNeeded(){
    if (!qRecorder) {
      qRecorder = createRecorderController({
        statusEl: qStatus,
        onText: (text) => {
          const fixed = applyCorrections(STORE_Q_CORR, text).trim();
          clinicalQuestion.value = fixed;
          flashStatus(qStatus, "Question captured.");
        }
      });
    }
    if (!nRecorder) {
      nRecorder = createRecorderController({
        statusEl: wrStatus,
        onText: (text) => {
          const fixed = applyCorrections(STORE_WR_CORR, text).trim();
          if (!fixed) return;
          const current = (wrNote.value || "").trim();
          wrNote.value = current ? (current + "\n" + fixed) : fixed;
          flashStatus(wrStatus, "Notes captured.");
        }
      });
    }
  }

  dictateQuestionBtn.addEventListener("click", async () => {
    const ok = await ensureMicPermission(qStatus);
    if (!ok) return;
    await initRecordersIfNeeded();

    if (!qRecorder.isRecording()) {
      dictateQuestionBtn.textContent = "‚èπ Stop";
      qRecorder.start();
    } else {
      dictateQuestionBtn.textContent = "üéô Dictate";
      qRecorder.stop();
    }
  });

  dictateWrBtn.addEventListener("click", async () => {
    const ok = await ensureMicPermission(wrStatus);
    if (!ok) return;
    await initRecordersIfNeeded();

    if (!nRecorder.isRecording()) {
      dictateWrBtn.textContent = "‚èπ Stop";
      nRecorder.start();
    } else {
      dictateWrBtn.textContent = "üéô Dictate";
      nRecorder.stop();
    }
  });

  // Init
  renderSidebar();
  flashStatus(qStatus, "Ready. Enter=Generate, Shift+Enter=new line.");
  flashStatus(wrStatus, "Notes mic: idle.");
});
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clinical Engine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
  <div class="app-root">
    <div class="shell">
      <div class="layout">

        <!-- SIDEBAR -->
        <aside class="sidebar">
          <div class="sidebar-header">
            <div class="sidebar-brand">
              <div class="brand-logo"></div>
              <div class="brand-text">
                <div class="brand-title">EBM</div>
                <div class="sidebar-title">Clinical Engine</div>
              </div>
            </div>

            <input id="sidebarSearch" class="topic-search" type="text" placeholder="Search saved..." />
          </div>

          <div class="sidebar-subhead">Saved Clinical Questions</div>
          <div id="savedQuestionsList" class="conversation-list"></div>

          <div class="sidebar-subhead">Consultation Notes (saved)</div>
          <div id="savedWrList" class="conversation-list"></div>

          <div class="sidebar-footer">
            <span class="sidebar-hint">Locally stored ‚Ä¢ Per device</span>
          </div>
        </aside>

        <!-- MAIN -->
        <div class="main-region">
          <header class="header">
            <h1 class="title">CLINICAL ENGINE</h1>
            <p class="subtitle">Clinical questions (top) + consultation notes (below). Dictation never triggers the Clinical Engine.</p>
          </header>

          <!-- TOP ROW -->
          <main class="grid">
            <!-- QUESTION -->
            <section class="card input-card">
              <label class="label" for="clinicalQuestion">Clinical Question</label>

              <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                <label class="label" style="margin:0;">Mode</label>
                <select id="modeSelect" class="topic-search" style="max-width:220px;">
                  <option value="clinical" selected>Clinical</option>
                  <option value="dva">DVA Referral Check</option>
                </select>
              </div>

              <textarea
                id="clinicalQuestion"
                class="textarea"
                rows="7"
                placeholder="Enter clinical question OR paste DVA patient details. Enter = Generate, Shift+Enter = new line."
              ></textarea>

              <div class="actions actions-compact">
                <button id="generateBtn" class="btn btn-compact" type="button">Generate</button>
                <button id="dictateQuestionBtn" class="btn btn-compact" type="button">üéô Dictate</button>
                <button id="incorrectQuestionBtn" class="btn btn-compact" type="button">Incorrect</button>
                <button id="clearQuestionBtn" class="btn btn-compact" type="button">Clear</button>
              </div>

              <div id="qStatus" class="mic-status">Question mic: idle</div>
            </section>

            <!-- ANSWER -->
            <section class="card output-card">
              <div class="output-header">
                <h2 class="output-title">Answers</h2>
                <button id="copyAllBtn" class="copy-btn main-copy-btn" disabled type="button">Copy All</button>
              </div>

              <div id="answerLoader" class="answer-loader hidden">
                <div class="loader"></div>
                <div class="loader-text">Generating structured answer‚Ä¶</div>
              </div>

              <div class="output-body">
                <div id="answer" class="answer placeholder">Your answer will appear here.</div>
              </div>
            </section>
          </main>

          <div class="divider-spacer"></div>

          <!-- CONSULTATION NOTES -->
          <section class="card wr-card">
            <div class="wr-head">
              <div>
                <div class="label wr-label">Consultation Notes</div>
                <div class="wr-sub">Dictation never triggers the Clinical Engine.</div>
              </div>

              <div class="actions actions-compact">
                <button id="dictateWrBtn" class="btn btn-compact" type="button">üéô Dictate</button>
                <button id="incorrectWrBtn" class="btn btn-compact" type="button">Incorrect</button>
                <button id="copyWrBtn" class="btn btn-compact" type="button">Copy</button>
                <button id="saveWrBtn" class="btn btn-compact" type="button">Save</button>
                <button id="newWrBtn" class="btn btn-compact" type="button">New</button>
              </div>
            </div>

            <textarea id="wrNote" class="textarea" rows="16" placeholder="Dictate or type freely here‚Ä¶"></textarea>
            <div id="wrStatus" class="mic-status">Notes mic: idle</div>
          </section>

        </div>
      </div>
    </div>
  </div>

<script>
window.addEventListener("DOMContentLoaded", () => {
  // Storage keys
  const STORE_Q_CORR = "ebm_q_corrections_v7";
  const STORE_WR_CORR = "ebm_wr_corrections_v7";
  const STORE_SAVED_QA = "ebm_saved_qa_v7";
  const STORE_SAVED_NOTES = "ebm_saved_notes_v7";

  // Elements
  const modeSelect = document.getElementById("modeSelect");

  const clinicalQuestion = document.getElementById("clinicalQuestion");
  const generateBtn = document.getElementById("generateBtn");
  const dictateQuestionBtn = document.getElementById("dictateQuestionBtn");
  const incorrectQuestionBtn = document.getElementById("incorrectQuestionBtn");
  const clearQuestionBtn = document.getElementById("clearQuestionBtn");

  const wrNote = document.getElementById("wrNote");
  const dictateWrBtn = document.getElementById("dictateWrBtn");
  const incorrectWrBtn = document.getElementById("incorrectWrBtn");
  const copyWrBtn = document.getElementById("copyWrBtn");
  const saveWrBtn = document.getElementById("saveWrBtn");
  const newWrBtn = document.getElementById("newWrBtn");

  const answerEl = document.getElementById("answer");
  const answerLoader = document.getElementById("answerLoader");
  const copyAllBtn = document.getElementById("copyAllBtn");

  const qStatus = document.getElementById("qStatus");
  const wrStatus = document.getElementById("wrStatus");

  const savedQuestionsList = document.getElementById("savedQuestionsList");
  const savedWrList = document.getElementById("savedWrList");
  const sidebarSearch = document.getElementById("sidebarSearch");

  // Utils
  function norm(s) { return (s || "").toLowerCase().replace(/\s+/g, " ").trim(); }
  function escapeHtml(str) {
    return (str || "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
  }
  function safeJsonParse(s, fallback){ try { return JSON.parse(s); } catch { return fallback; } }
  async function copyText(text){ if (!text) return; try { await navigator.clipboard.writeText(text); } catch {} }
  function flashStatus(el, msg){ if (el) el.textContent = msg; }

  // Structured answer builder (collapsible)
  function hasNonEmpty(arr){ return Array.isArray(arr) && arr.some(l => (l||"").trim() !== ""); }

  function buildStructuredHtml(raw) {
    if (!raw) return "";
    let text = String(raw)
      .replace(/\r/g, "")
      .replace(/\*\*(.*?)\*\*/g, "$1")
      .replace(/#{1,6}\s*/g, "");

    const sectionOrder = [
      "Summary",
      "Assessment",
      "Diagnosis",
      "Investigations",
      "Treatment",
      "Monitoring",
      "Follow-up & Safety Netting",
      "Red Flags",
      "References",
    ];

    const lines = text.split("\n");
    const sections = [];
    let current = { title: "Summary", content: [] };
    let seenExplicit = false;

    function isHeading(line){
      const t = (line||"").trim().replace(/:$/, "");
      const match = sectionOrder.find(h => h.toLowerCase() === t.toLowerCase());
      return match || null;
    }

    for (const rawLine of lines) {
      const line = (rawLine||"").trim();
      if (!line) { current.content.push(""); continue; }
      const heading = isHeading(line);
      if (heading) {
        if (hasNonEmpty(current.content)) sections.push(current);
        current = { title: heading, content: [] };
        seenExplicit = true;
      } else {
        current.content.push(line);
      }
    }
    if (hasNonEmpty(current.content)) sections.push(current);

    if (!seenExplicit) {
      return `<div class="answer-paragraph">${escapeHtml(text)}</div>`;
    }

    let html = "";
    let idx = 0;

    for (const sec of sections) {
      if (!hasNonEmpty(sec.content)) continue;
      const id = `sec-${idx++}`;
      const inner = sec.content
        .filter(l => (l||"").trim() !== "")
        .map(l => `<p class="answer-paragraph">${escapeHtml(l.trim())}</p>`)
        .join("");

      const alwaysOpen = (sec.title === "Summary");

      if (alwaysOpen) {
        html += `
          <div class="section">
            <div class="section-header static">
              <span>${escapeHtml(sec.title)}</span>
              <button class="section-copy-btn copy-btn" data-target="${id}" type="button">Copy</button>
            </div>
            <div class="section-body static-body" data-section="${id}">
              ${inner}
            </div>
          </div>`;
      } else {
        html += `
          <div class="section">
            <div class="collapsible-header">
              <button class="collapsible" data-target="${id}" type="button">${escapeHtml(sec.title)}</button>
              <button class="section-copy-btn copy-btn" data-target="${id}" type="button">Copy</button>
            </div>
            <div class="collapsible-content" data-section="${id}" style="display:none;">
              ${inner}
            </div>
          </div>`;
      }
    }

    return html || `<div class="answer-paragraph">${escapeHtml(text)}</div>`;
  }

  document.addEventListener("click", async (e) => {
    const t = e.target;

    if (t.classList && t.classList.contains("collapsible")) {
      const id = t.dataset.target;
      const content = document.querySelector(`.collapsible-content[data-section="${id}"]`);
      if (!content) return;
      const open = content.style.display === "block";
      content.style.display = open ? "none" : "block";
      t.classList.toggle("active", !open);
      return;
    }

    if (t.classList && t.classList.contains("section-copy-btn")) {
      const id = t.dataset.target;
      const section = document.querySelector(`[data-section="${id}"]`);
      if (!section) return;
      const text = (section.innerText || "").trim();
      if (!text) return;
      await copyText(text);
      return;
    }
  });

  // Corrections
  function loadCorrections(key){ return safeJsonParse(localStorage.getItem(key) || "{}", {}); }
  function saveCorrections(key, map){ localStorage.setItem(key, JSON.stringify(map || {})); }
  function applyCorrections(key, text){
    let out = text || "";
    const map = loadCorrections(key);
    const keys = Object.keys(map).sort((a,b)=>b.length-a.length);
    for (const k of keys) {
      const v = map[k];
      if (!k || !v) continue;
      const re = new RegExp(k.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
      out = out.replace(re, v);
    }
    return out;
  }
  function addCorrectionFromSelection(textarea, storeKey){
    const s = textarea.selectionStart;
    const e = textarea.selectionEnd;
    const selected = (textarea.value || "").slice(s, e).trim();
    if (!selected) { alert("Highlight the incorrect words first."); return; }
    const correct = prompt("What should it be instead?", selected);
    if (!correct || !correct.trim()) return;

    const map = loadCorrections(storeKey);
    map[selected] = correct.trim();
    saveCorrections(storeKey, map);

    const before = textarea.value.slice(0, s);
    const after = textarea.value.slice(e);
    textarea.value = before + correct.trim() + after;
  }

  incorrectQuestionBtn.addEventListener("click", () => addCorrectionFromSelection(clinicalQuestion, STORE_Q_CORR));
  incorrectWrBtn.addEventListener("click", () => addCorrectionFromSelection(wrNote, STORE_WR_CORR));

  // Sidebar saved items
  function loadSavedQA(){ return safeJsonParse(localStorage.getItem(STORE_SAVED_QA) || "[]", []); }
  function saveSavedQA(list){ localStorage.setItem(STORE_SAVED_QA, JSON.stringify(list || [])); }
  function loadSavedNotes(){ return safeJsonParse(localStorage.getItem(STORE_SAVED_NOTES) || "[]", []); }
  function saveSavedNotes(list){ localStorage.setItem(STORE_SAVED_NOTES, JSON.stringify(list || [])); }

  function addSavedQA(question, answerText){
    const list = loadSavedQA();
    const title = question.length > 60 ? question.slice(0, 60).trim() + "‚Ä¶" : question.trim();
    list.unshift({ id: Date.now(), title, question, answer: answerText || "", ts: Date.now() });
    saveSavedQA(list.slice(0, 80));
  }

  function addSavedNote(content){
    const list = loadSavedNotes();
    const title = "Notes " + new Date().toLocaleString();
    list.unshift({ id: Date.now(), title, content, ts: Date.now() });
    saveSavedNotes(list.slice(0, 80));
  }

  function renderSidebar(){
    const term = norm(sidebarSearch.value || "");

    const qa = loadSavedQA();
    savedQuestionsList.innerHTML = "";
    if (!qa.length) {
      savedQuestionsList.innerHTML = '<div class="conv-empty">No saved questions yet.</div>';
    } else {
      qa.forEach((item, idx) => {
        const show = !term || norm(item.title).includes(term) || norm(item.question).includes(term);
        if (!show) return;

        const row = document.createElement("div");
        row.className = "conversation-item";

        const main = document.createElement("div");
        main.className = "conv-main";
        main.innerHTML = `<div class="conv-title">${escapeHtml(item.title || "Question")}</div>`;

        const copy = document.createElement("button");
        copy.className = "conv-delete";
        copy.textContent = "‚ßâ";
        copy.title = "Copy Q+A";

        const del = document.createElement("button");
        del.className = "conv-delete";
        del.textContent = "‚úï";
        del.title = "Remove";

        main.addEventListener("click", () => {
          clinicalQuestion.value = item.question || "";
          answerEl.innerHTML = item.answer ? buildStructuredHtml(item.answer) : "Your answer will appear here.";
          copyAllBtn.disabled = !(item.answer || "").trim();
          clinicalQuestion.focus();
        });

        copy.addEventListener("click", async (e) => {
          e.stopPropagation();
          const out = `Q: ${item.question || ""}\n\nA:\n${item.answer || ""}`.trim();
          if (out) await copyText(out);
        });

        del.addEventListener("click", (e) => {
          e.stopPropagation();
          const list = loadSavedQA();
          list.splice(idx, 1);
          saveSavedQA(list);
          renderSidebar();
        });

        row.appendChild(main);
        row.appendChild(copy);
        row.appendChild(del);
        savedQuestionsList.appendChild(row);
      });
    }

    const notes = loadSavedNotes();
    savedWrList.innerHTML = "";
    if (!notes.length) {
      savedWrList.innerHTML = '<div class="conv-empty">No saved notes yet.</div>';
    } else {
      notes.forEach((item, idx) => {
        const show = !term || norm(item.title).includes(term) || norm(item.content).includes(term);
        if (!show) return;

        const row = document.createElement("div");
        row.className = "conversation-item";

        const main = document.createElement("div");
        main.className = "conv-main";
        main.innerHTML = `<div class="conv-title">${escapeHtml(item.title || "Notes")}</div>`;

        const copy = document.createElement("button");
        copy.className = "conv-delete";
        copy.textContent = "‚ßâ";
        copy.title = "Copy note";

        const del = document.createElement("button");
        del.className = "conv-delete";
        del.textContent = "‚úï";
        del.title = "Remove";

        main.addEventListener("click", () => {
          wrNote.value = item.content || "";
          wrNote.focus();
        });

        copy.addEventListener("click", async (e) => {
          e.stopPropagation();
          if ((item.content || "").trim()) await copyText(item.content.trim());
        });

        del.addEventListener("click", (e) => {
          e.stopPropagation();
          const list = loadSavedNotes();
          list.splice(idx, 1);
          saveSavedNotes(list);
          renderSidebar();
        });

        row.appendChild(main);
        row.appendChild(copy);
        row.appendChild(del);
        savedWrList.appendChild(row);
      });
    }
  }

  sidebarSearch.addEventListener("input", renderSidebar);

  // Generate
  async function generate(){
    const query = (clinicalQuestion.value || "").trim();
    if (!query) return;

    const mode = (modeSelect && modeSelect.value) ? modeSelect.value : "clinical";

    generateBtn.disabled = true;
    copyAllBtn.disabled = true;
    answerLoader.classList.remove("hidden");
    answerEl.innerHTML = "";

    try {
      const res = await fetch("/api/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query, mode })
      });

      const data = await res.json();

      if (data.answer) {
        answerEl.innerHTML = buildStructuredHtml(data.answer);
        copyAllBtn.disabled = !(data.answer || "").trim();
        flashStatus(qStatus, "Generated.");
      } else {
        answerEl.textContent = (data.error || "No response.").trim();
        copyAllBtn.disabled = true;
        flashStatus(qStatus, "Generate failed.");
      }
    } catch (e) {
      console.error(e);
      answerEl.textContent = "Error generating answer.";
      copyAllBtn.disabled = true;
      flashStatus(qStatus, "Generate error.");
    } finally {
      answerLoader.classList.add("hidden");
      generateBtn.disabled = false;
    }
  }

  generateBtn.addEventListener("click", generate);

  // Enter = Generate, Shift+Enter = newline
  clinicalQuestion.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      generate();
    }
  });

  copyAllBtn.addEventListener("click", async () => {
    const text = (answerEl.innerText || "").trim();
    if (!text) return;
    await copyText(text);
  });

  // Clear saves Q+A to sidebar (if present)
  clearQuestionBtn.addEventListener("click", () => {
    const q = (clinicalQuestion.value || "").trim();
    const a = (answerEl.innerText || "").trim();
    if (q && a) addSavedQA(q, a);

    clinicalQuestion.value = "";
    answerEl.innerHTML = "Your answer will appear here.";
    copyAllBtn.disabled = true;
    flashStatus(qStatus, "Cleared (saved).");
    renderSidebar();
  });

  // Notes buttons
  copyWrBtn.addEventListener("click", async () => {
    const text = (wrNote.value || "").trim();
    if (!text) return;
    await copyText(text);
    flashStatus(wrStatus, "Copied.");
  });

  saveWrBtn.addEventListener("click", () => {
    const text = (wrNote.value || "").trim();
    if (!text) return;
    addSavedNote(text);
    flashStatus(wrStatus, "Saved.");
    renderSidebar();
  });

  newWrBtn.addEventListener("click", () => {
    const current = (wrNote.value || "").trim();
    if (current) {
      const save = confirm("Save this note before starting a new one?");
      if (save) addSavedNote(current);
    }
    wrNote.value = "";
    flashStatus(wrStatus, "Cleared.");
    renderSidebar();
  });

  // Dictation (MediaRecorder ‚Üí /api/transcribe)
  function pickMimeType(){
    const candidates = ["audio/webm;codecs=opus", "audio/webm", "audio/ogg;codecs=opus", "audio/ogg"];
    for (const t of candidates) {
      if (window.MediaRecorder?.isTypeSupported?.(t)) return t;
    }
    return "";
  }

  async function ensureMicPermission(statusEl){
    if (!window.isSecureContext) {
      flashStatus(statusEl, "Mic error: must be HTTPS.");
      return false;
    }
    if (!navigator.mediaDevices?.getUserMedia) {
      flashStatus(statusEl, "Mic error: getUserMedia unsupported.");
      return false;
    }
    try {
      const s = await navigator.mediaDevices.getUserMedia({ audio: true });
      s.getTracks().forEach(t => t.stop());
      return true;
    } catch (e) {
      console.warn(e);
      flashStatus(statusEl, "Mic blocked: allow microphone permission.");
      return false;
    }
  }

  function dedupeRepeats(text){
    if (!text) return "";
    let t = String(text);
    t = t.replace(/\b(\w+)(\s+\1){2,}\b/gi, "$1");
    t = t.replace(/\s{2,}/g, " ").trim();
    return t;
  }
  function normaliseDictation(text){
    let t = dedupeRepeats(text);
    t = t.replace(/\b(um|uh|like|you know)\b/gi, "");
    t = t.replace(/\s{2,}/g, " ").trim();
    return t;
  }

  async function transcribeBlob(blob){
    const form = new FormData();
    form.append("audio", blob, "audio.webm");
    const res = await fetch("/api/transcribe", { method: "POST", body: form });
    const raw = await res.text();

    let data = {};
    try { data = JSON.parse(raw); } catch {}
    if (!res.ok) throw new Error(data.error || raw || ("HTTP " + res.status));
    return (data.text || "").trim();
  }

  function createRecorderController({ statusEl, onText }){
    let stream = null;
    let recorder = null;
    let chunks = [];
    let recording = false;

    async function start(){
      if (recording) return;
      recording = true;
      chunks = [];

      flashStatus(statusEl, "Mic: starting‚Ä¶");
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      const mimeType = pickMimeType();
      recorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);

      recorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };

      recorder.onstart = () => flashStatus(statusEl, "Mic: recording‚Ä¶");

      recorder.onstop = async () => {
        try {
          flashStatus(statusEl, "Mic: transcribing‚Ä¶");
          const blob = new Blob(chunks, { type: recorder.mimeType || "audio/webm" });
          if (!blob || blob.size < 300) {
            flashStatus(statusEl, "Mic: no audio detected.");
            return;
          }
          const textRaw = await transcribeBlob(blob);
          const textClean = normaliseDictation(textRaw);
          if (textClean) onText(textClean);
          flashStatus(statusEl, "Mic: done.");
        } catch (e) {
          console.warn(e);
          flashStatus(statusEl, "Mic: transcribe failed.");
        } finally {
          try { stream?.getTracks()?.forEach(t => t.stop()); } catch {}
          stream = null;
          recorder = null;
          chunks = [];
          recording = false;
        }
      };

      recorder.start();
    }

    function stop(){
      if (!recording || !recorder) return;
      flashStatus(statusEl, "Mic: stopping‚Ä¶");
      try { recorder.stop(); } catch(e) {}
    }

    return { start, stop, isRecording: () => recording };
  }

  let qRecorder = null;
  let nRecorder = null;

  async function initRecordersIfNeeded(){
    if (!qRecorder) {
      qRecorder = createRecorderController({
        statusEl: qStatus,
        onText: (text) => {
          const fixed = applyCorrections(STORE_Q_CORR, text).trim();
          clinicalQuestion.value = fixed;
          flashStatus(qStatus, "Question captured.");
        }
      });
    }
    if (!nRecorder) {
      nRecorder = createRecorderController({
        statusEl: wrStatus,
        onText: (text) => {
          const fixed = applyCorrections(STORE_WR_CORR, text).trim();
          if (!fixed) return;
          const current = (wrNote.value || "").trim();
          wrNote.value = current ? (current + "\n" + fixed) : fixed;
          flashStatus(wrStatus, "Notes captured.");
        }
      });
    }
  }

  dictateQuestionBtn.addEventListener("click", async () => {
    const ok = await ensureMicPermission(qStatus);
    if (!ok) return;
    await initRecordersIfNeeded();

    if (!qRecorder.isRecording()) {
      dictateQuestionBtn.textContent = "‚èπ Stop";
      qRecorder.start();
    } else {
      dictateQuestionBtn.textContent = "üéô Dictate";
      qRecorder.stop();
    }
  });

  dictateWrBtn.addEventListener("click", async () => {
    const ok = await ensureMicPermission(wrStatus);
    if (!ok) return;
    await initRecordersIfNeeded();

    if (!nRecorder.isRecording()) {
      dictateWrBtn.textContent = "‚èπ Stop";
      nRecorder.start();
    } else {
      dictateWrBtn.textContent = "üéô Dictate";
      nRecorder.stop();
    }
  });

  // Init
  renderSidebar();
  flashStatus(qStatus, "Ready. Enter=Generate, Shift+Enter=new line.");
  flashStatus(wrStatus, "Notes mic: idle.");
});
</script>

</body>
</html>
