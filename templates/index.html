<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clinical Engine | EBM Session</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
  <div class="app-root">
    <div class="shell">
      <div class="layout">
        <aside class="sidebar">
          <div class="sidebar-header">
            <div class="sidebar-brand">
              <div class="brand-logo"></div>
              <div class="brand-text">
                <div class="brand-title">EBM</div>
                <div class="sidebar-title">EBM Session</div>
              </div>
            </div>
            <input id="topicSearch" class="topic-search" type="text" placeholder="Search topics..." />
          </div>
          <div id="conversationList" class="conversation-list"></div>
          <div class="sidebar-footer">
            <span class="sidebar-hint">Locally stored • Per device</span>
          </div>
        </aside>

        <div class="main-region">
          <header class="header">
            <h1 class="title">CLINICAL ENGINE</h1>
            <p class="subtitle">Enter a clinical question to generate an evidence-based answer.</p>
          </header>

          <main class="grid">
            <section class="card input-card">
              <label class="label" for="question">Clinical Question</label>
              <textarea id="question" class="textarea" rows="6"></textarea>
              <div class="actions">
                <button id="generateBtn" class="btn">Generate</button>
              </div>
            </section>

            <section class="card output-card">
              <div class="output-header">
                <h2 class="output-title">Answers</h2>
              </div>

              <div id="answerLoader" class="answer-loader hidden">
                <div class="loader"></div>
                <div class="loader-text">Generating structured answer…</div>
              </div>

              <div class="output-body">
                <div id="answer" class="answer placeholder">
                  Tap anywhere to enable voice, or hold SPACE to speak.
                </div>
              </div>
            </section>
          </main>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   CORE GENERATE
   ========================================================= */
const questionInput = document.getElementById("question");
const generateBtn = document.getElementById("generateBtn");
const answerEl = document.getElementById("answer");
const answerLoader = document.getElementById("answerLoader");

function setStatus(msg) {
  answerEl.classList.remove("placeholder");
  answerEl.textContent = msg;
}

async function generate() {
  const query = questionInput.value.trim();
  if (!query) return;

  answerLoader.classList.remove("hidden");
  answerEl.textContent = "";

  try {
    const res = await fetch("/api/generate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query })
    });
    const data = await res.json();
    answerEl.textContent = data.answer || data.error || "No response.";
  } catch {
    answerEl.textContent = "Error generating answer.";
  } finally {
    answerLoader.classList.add("hidden");
  }
}

generateBtn.onclick = generate;

/* =========================================================
   VOICE INPUT (RELIABLE PUSH-TO-TALK)
   Hold SPACE → speak → release → transcribe → generate
   ========================================================= */
let mediaRecorder = null;
let audioChunks = [];
let recording = false;

async function startRecording() {
  if (recording) return;
  recording = true;
  audioChunks = [];

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);

    mediaRecorder.ondataavailable = e => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      setStatus("Voice: transcribing…");

      const blob = new Blob(audioChunks, { type: "audio/webm" });
      const form = new FormData();
      form.append("audio", blob, "speech.webm");

      try {
        const res = await fetch("/api/transcribe", {
          method: "POST",
          body: form
        });
        const data = await res.json();

        if (data.text) {
          questionInput.value = data.text.trim();
          setStatus("Voice captured — generating…");
          setTimeout(generate, 150);
        } else {
          setStatus("Voice heard but no text recognised.");
        }
      } catch {
        setStatus("Voice transcription failed.");
      }

      stream.getTracks().forEach(t => t.stop());
      recording = false;
    };

    mediaRecorder.start();
    setStatus("Recording… release SPACE to send");

  } catch {
    recording = false;
    setStatus("Microphone blocked. Enable mic permission and refresh.");
  }
}

function stopRecording() {
  if (recording && mediaRecorder) {
    mediaRecorder.stop();
  }
}

document.addEventListener("keydown", e => {
  if (e.code === "Space" && document.activeElement !== questionInput) {
    e.preventDefault();
    startRecording();
  }
});

document.addEventListener("keyup", e => {
  if (e.code === "Space") {
    e.preventDefault();
    stopRecording();
  }
});

/* =========================================================
   WAKE WORD (LIGHTWEIGHT, SAFE)
   ========================================================= */
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
if (SpeechRecognition) {
  const rec = new SpeechRecognition();
  rec.lang = "en-AU";
  rec.continuous = true;
  rec.interimResults = false;

  rec.onresult = e => {
    const t = e.results[e.results.length - 1][0].transcript.toLowerCase();
    if (t.includes("hi ebm") || t.includes("hey ebm") || t.includes("okay ebm")) {
      setStatus("Wake word detected — speak your question.");
    }
  };

  document.addEventListener("click", () => {
    try { rec.start(); } catch {}
  }, { once: true });
}
</script>

</body>
</html>
