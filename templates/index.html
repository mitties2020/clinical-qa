<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clinical Engine | EBM Session</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
  <div class="app-root">
    <div class="shell">
      <div class="layout">
        <aside class="sidebar">
          <div class="sidebar-header">
            <div class="sidebar-brand">
              <div class="brand-logo"></div>
              <div class="brand-text">
                <div class="brand-title">EBM</div>
                <div class="sidebar-title">EBM Session</div>
              </div>
            </div>
            <input id="topicSearch" class="topic-search" type="text" placeholder="Search topics..." />
          </div>
          <div id="conversationList" class="conversation-list"></div>
          <div class="sidebar-footer">
            <span class="sidebar-hint">Locally stored • Per device</span>
          </div>
        </aside>

        <div class="main-region">
          <header class="header">
            <h1 class="title">CLINICAL ENGINE</h1>
            <p class="subtitle">Enter a clinical question to generate an evidence-based answer.</p>
          </header>

          <main class="grid">
            <section class="card input-card">
              <label class="label" for="question">Clinical Question</label>
              <textarea id="question" class="textarea" rows="6"></textarea>
              <div class="actions">
                <button id="generateBtn" class="btn">Generate</button>
              </div>
            </section>

            <section class="card output-card">
              <div class="output-header">
                <h2 class="output-title">Answers</h2>
                <button id="copyAllBtn" class="copy-btn main-copy-btn" disabled>Copy All</button>
              </div>

              <div id="answerLoader" class="answer-loader hidden">
                <div class="loader"></div>
                <div class="loader-text">Generating structured answer…</div>
              </div>

              <div class="output-body">
                <div id="answer" class="answer placeholder">Your structured response will appear here.</div>
              </div>
            </section>
          </main>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------------- BASIC GENERATE ----------------
    const questionInput = document.getElementById("question");
    const generateBtn = document.getElementById("generateBtn");
    const answerEl = document.getElementById("answer");
    const answerLoader = document.getElementById("answerLoader");

    function setStatus(msg) {
      // visible debug without aesthetic changes
      answerEl.classList.remove("placeholder");
      answerEl.textContent = msg;
    }

    async function generate() {
      const query = questionInput.value.trim();
      if (!query) return;

      answerLoader.classList.remove("hidden");
      answerEl.classList.remove("placeholder");
      answerEl.textContent = "";

      try {
        const res = await fetch("/api/generate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query })
        });
        const data = await res.json();
        answerEl.textContent = data.answer || data.error || "No response.";
      } catch (e) {
        console.error(e);
        answerEl.textContent = "Error generating answer.";
      } finally {
        answerLoader.classList.add("hidden");
      }
    }

    generateBtn.addEventListener("click", generate);

    questionInput.addEventListener("keydown", e => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        generate();
      }
    });

    // =========================================================
    // VOICE ACTIVATION (WAKE WORD) USING /api/transcribe
    // - FIRST TAP enables mic (browser requirement)
    // - Then say: "Hi EBM ...your question..."
    // - Auto-fills #question and clicks Generate
    // =========================================================
    (function () {
      const WAKE = ["hi ebm", "hey ebm", "okay ebm"];
      const CHUNK_MS = 4000;       // fewer calls
      const COOLDOWN_MS = 6000;    // avoid double-fire

      let stream = null;
      let recorder = null;
      let chunks = [];
      let running = false;
      let lastFire = 0;
      let rollingText = "";
      let mimeTypeChosen = "";

      function norm(s) {
        return (s || "").toLowerCase().replace(/\s+/g, " ").trim();
      }

      function pickMimeType() {
        const candidates = [
          "audio/webm;codecs=opus",
          "audio/webm",
          "audio/ogg;codecs=opus",
          "audio/ogg"
        ];
        for (const t of candidates) {
          if (window.MediaRecorder?.isTypeSupported?.(t)) return t;
        }
        return "";
      }

      function findWakeAndExtract(text) {
        const lower = norm(text);
        for (const w of WAKE) {
          if (lower.includes(w)) {
            const re = new RegExp(w, "i");
            const after = text.replace(re, "").trim().replace(/^[,:\-\s]+/, "");
            return after || "";
          }
        }
        return null;
      }

      async function transcribeBlob(blob) {
        const form = new FormData();
        form.append("audio", blob, "chunk.webm");

        const res = await fetch("/api/transcribe", { method: "POST", body: form });
        const raw = await res.text();

        let data = {};
        try { data = JSON.parse(raw); } catch {}

        if (!res.ok) {
          console.warn("Voice: /api/transcribe failed", res.status, data.error || raw);
          setStatus("Voice: transcribe failed (" + res.status + "). Check Render logs.");
          return "";
        }
        return (data.text || "").trim();
      }

      async function startVoiceLoop() {
        if (running) return;
        running = true;

        setStatus("Voice: requesting microphone permission…");

        try {
          stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        } catch (e) {
          console.warn("Voice: mic blocked/denied", e);
          setStatus("Voice: microphone blocked. Enable mic permission for this site in Chrome settings.");
          running = false;
          return;
        }

        mimeTypeChosen = pickMimeType();
        if (!window.MediaRecorder) {
          setStatus("Voice: MediaRecorder not supported in this browser.");
          running = false;
          return;
        }

        setStatus("Voice: armed. Say 'Hi EBM …'");

        recorder = mimeTypeChosen
          ? new MediaRecorder(stream, { mimeType: mimeTypeChosen })
          : new MediaRecorder(stream);

        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) chunks.push(e.data);
        };

        recorder.start();

        const interval = setInterval(async () => {
          if (!running) { clearInterval(interval); return; }

          try { recorder.stop(); } catch { return; }

          setTimeout(async () => {
            if (!running) return;

            const blob = new Blob(chunks, { type: recorder.mimeType || "audio/webm" });
            chunks = [];

            // restart recorder immediately
            try {
              recorder = mimeTypeChosen
                ? new MediaRecorder(stream, { mimeType: mimeTypeChosen })
                : new MediaRecorder(stream);

              recorder.ondataavailable = (e) => {
                if (e.data && e.data.size > 0) chunks.push(e.data);
              };
              recorder.start();
            } catch (e) {
              console.warn("Voice: recorder restart failed", e);
              setStatus("Voice: recorder restart failed.");
              return;
            }

            if (!blob || blob.size < 1500) return;

            setStatus("Voice: sending audio to /api/transcribe … (watch Render logs for POST)");

            const text = await transcribeBlob(blob);
            if (!text) return;

            rollingText = (rollingText + " " + text).trim();
            if (rollingText.length > 350) rollingText = rollingText.slice(-350);

            const now = Date.now();
            if (now - lastFire < COOLDOWN_MS) return;

            const extracted = findWakeAndExtract(rollingText);
            if (extracted !== null) {
              if (!extracted) {
                setStatus("Voice: wake word heard. Say the question…");
                return;
              }

              lastFire = now;
              questionInput.value = extracted;
              rollingText = "";

              setStatus("Voice: question captured. Generating…");
              setTimeout(() => generateBtn.click(), 150);
            } else {
              setStatus("Voice: armed. Say 'Hi EBM …' (heard: " + text + ")");
            }
          }, 50);
        }, CHUNK_MS);
      }

      // Start on first tap anywhere (required by browser)
      document.addEventListener("click", function firstTap() {
        document.removeEventListener("click", firstTap, true);
        startVoiceLoop();
      }, true);

      // Helpful hint when page loads
      window.addEventListener("DOMContentLoaded", () => {
        setStatus("Voice: tap once anywhere to enable mic, then say 'Hi EBM …'");
      });
    })();
  </script>
</body>
</html>
